// automatically generated by the FlatBuffers compiler, do not modify

#pragma once
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/kvstore_builder.h"

namespace {{namespace}} {

{% for item in __fbs_meta__['tables'] %}
{% set table_name = item.__name__ %}

struct {{table_name}};
struct {{table_name}}T;

struct {{table_name}}T : public flatbuffers::NativeTable {
{% for member, type in item['_fspec'].items() %}
{% set cpp_type = cpp_types[type[1]] %}
  {{cpp_type}} {{member}};
{% endfor %}
};

struct {{table_name}} FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    {% set i = 4 %}
    // keys
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    {% set cpp_type = cpp_types[type[1]] %}
    {% set key = 'key' in type[2] %}
    {% set string_key = key and (cpp_type == 'std::string') %}
    {% if key and not string_key %}
    VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endif %}
    {% endfor %}

    // values
    {% set i = 4 + 2 * item['meta']['key_fields'] | length %}
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    {% set cpp_type = cpp_types[type[1]] %}
    {% set key = 'key' in type[2] %}
    {% set string_key = key and (cpp_type == 'std::string') %}
    {% if string_key or not key %}
    VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endif %}
    {% endfor %}
  };
  // Internal
  enum {
    {% set i = 4 %}
    // keys
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    {% set cpp_type = cpp_types[type[1]] %}
    {% set key = 'key' in type[2] %}
    {% set string_key = key and (cpp_type == 'std::string') %}
    {% if key and not string_key %}
    _VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endif %}
    {% endfor %}

    // values
    {% set i = 4 %}
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    {% set cpp_type = cpp_types[type[1]] %}
    {% set key = 'key' in type[2] %}
    {% set string_key = key and (cpp_type == 'std::string') %}
    {% if string_key or not key %}
    _VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endif %}
    {% endfor %}
  };

  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set MEMBER = member.upper() %}
  {% set key = 'key' in type[2] %}
  {% set string_key = key and (cpp_type == 'std::string') %}
  {% if (cpp_type != 'std::string') %}
  {{cpp_type}} {{member}}() const { return GetField<{{cpp_type}}>(VT_{{MEMBER}}, 0); }
  bool mutate_{{member}}({{cpp_type}} _{{member}}) { return SetField<{{cpp_type}}>(VT_{{MEMBER}}, _{{member}}); }
  {% elif string_key %}
  const flatbuffers::IString *{{member}}() const { return reinterpret_cast<const flatbuffers::IString *>(GetAddressOf(VT_{{MEMBER}})); }
  flatbuffers::IString *mutable_{{member}}() { return reinterpret_cast<flatbuffers::IString *>(GetAddressOf(VT_{{MEMBER}})); }
  {% else %}
  const flatbuffers::String *{{member}}() const { return GetPointer<const flatbuffers::String *>(VT_{{MEMBER}}); }
  flatbuffers::String *mutable_{{member}}() { return GetPointer<flatbuffers::String *>(VT_{{MEMBER}}); }
  {% endif %}
  {% endfor %}

  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
           VerifyField<{{cpp_type}}>(verifier, VT_{{MEMBER}}) &&
     {% endfor %}
           verifier.EndTable();
  }
  void ByteOrderFields() {
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
       {%- if key %}
    flatbuffers::ByteOrderScalar<{{cpp_type}}>(GetAddressOf(VT_{{MEMBER}}));
       {% endif %}
     {% endfor %}
  }
  void FlatbufferOrderFields() {
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
       {%- if key %}
    flatbuffers::FlatbufferOrderScalar<{{cpp_type}}>(GetAddressOf(VT_{{MEMBER}}));
       {% endif %}
     {% endfor %}
  }
  {% for member in item['meta']['key_fields'] %}
     {% set type = item['_fspec'][member] %}
     {% set cpp_type = cpp_types[type[1]] %}
     {% set MEMBER = member.upper() %}
     {% if loop.first %}
  const uint8_t *GetKey() const {
    return GetAddressOf(VT_{{MEMBER}});
  }
     {% set FIRST_MEMBER = MEMBER %}
     {% endif %}
     {% if loop.last %}
  size_t GetKeySize() const {
    return GetAddressOf(VT_{{MEMBER}}) -
      GetAddressOf(VT_{{FIRST_MEMBER}}) +
      sizeof({{cpp_type}});
  }
     {% endif %}
  {% endfor %}
  {% for member in item['meta']['value_fields'] %}
     {% set type = item['_fspec'][member] %}
     {% set cpp_type = cpp_types[type[1]] %}
     {% set MEMBER = member.upper() %}
     {% if loop.first %}
  const uint8_t *GetValue() const {
    return GetAddressOf(VT_{{MEMBER}});
  }
     {% set FIRST_MEMBER = MEMBER %}
     {% endif %}
     {% if loop.last %}
  // FIXME
  size_t GetValueSize() const {
    return GetAddressOf(VT_{{MEMBER}}) -
      GetAddressOf(VT_NAME) +
      sizeof(flatbuffers::String) +
      1 * sizeof(flatbuffers::String);
  }
     {% endif %}
  {% endfor %}
  {{table_name}}T *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct {{table_name}}Builder {
  flatbuffers::KVStoreBuilder &fbb_;
  flatbuffers::uoffset_t start_;
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] %}
       {% set string_key = key and (cpp_type == 'std::string') %}
       {% if key %}
       {% set add_element = 'AddKeyElement' %}
       {% else %}
       {% set add_element = 'AddElement' %}
       {% endif %}
       {% if string_key %}
  void add_{{member}}(const {{cpp_type}}& {{member}}) { fbb_.{{add_element}}({{table_name}}::_VT_{{MEMBER}}, {{member}}, std::string()); }
       {% elif (cpp_type != 'std::string') %}
  void add_{{member}}({{cpp_type}} {{member}}) { fbb_.{{add_element}}<{{cpp_type}}>({{table_name}}::_VT_{{MEMBER}}, {{member}}, 0); }
       {% else %}
  void add_{{member}}(flatbuffers::Offset<flatbuffers::String> {{member}}) { fbb_.AddOffset({{table_name}}::_VT_{{MEMBER}}, {{member}}); }
       {% endif %}
     {% endfor %}
  {{table_name}}Builder(flatbuffers::KVStoreBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  {{table_name}}Builder &operator=(const {{table_name}}Builder &);
  flatbuffers::Offset<{{table_name}}> Finish() {
    {% set num_fields = item['_fspec'] | length %}
    auto o = flatbuffers::Offset<{{table_name}}>(fbb_.EndTable(start_, {{num_fields}}));
    {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] %}
       {% set string_key = key and (cpp_type == 'std::string') %}
       {% set required = 'required' in type[2] %}
       {% if required or key %}
    fbb_.Required(o, {{table_name}}::VT_{{MEMBER}});
       {% endif %}
     {% endfor %}
    return o;
  }
};

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::KVStoreBuilder &_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set key = 'key' in type[2] %}
  {% set string_key = key and (cpp_type == 'std::string') %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if string_key %}
    const {{cpp_type}}& {{member}} = ""{{delim}}
  {% elif (cpp_type != 'std::string') %}
    {{cpp_type}} {{member}} = 0{{delim}}
  {% else %}
    flatbuffers::Offset<flatbuffers::String> {{member}} = 0{{delim}}
  {% endif %}
  {% endfor %}
  ) {
  {{table_name}}Builder builder_(_fbb);
  {% for member, type in item['_fspec'].items() | reverse %}
  builder_.add_{{member}}({{member}});
  {% endfor %}
  return builder_.Finish();
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}Direct(flatbuffers::KVStoreBuilder &_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if (cpp_type != 'std::string') %}
    {{cpp_type}} {{member}} = 0{{delim}}
  {% else %}
    const char *{{member}} = nullptr{{delim}}
  {% endif %}
  {% endfor %}
  ) {
  return Create{{table_name}}(_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set key = 'key' in type[2] %}
  {% set string_key = key and (cpp_type == 'std::string') %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if (cpp_type != 'std::string') or string_key %}
    {{member}}{{delim}}
  {% else %}
    {{member}} ? _fbb.CreateValueString({{member}}) : 0{{delim}}
  {% endif %}
  {% endfor %}
  );
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::KVStoreBuilder &_fbb, const {{table_name}}T *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline {{table_name}}T *{{table_name}}::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void) resolver;
  auto _o = new {{table_name}}T();
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% if (cpp_type != 'std::string') %}
  { auto _e = {{member}}(); _o->{{member}}= _e; };
  {% else %}
  { auto _e = {{member}}(); if (_e) _o->{{member}}= _e->str(); };
  {% endif %}
  {% endfor %}
  return _o;
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::KVStoreBuilder &_fbb, const {{table_name}}T *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void) rehasher;
  return Create{{table_name}}(_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set key = 'key' in type[2] %}
  {% set string_key = key and (cpp_type == 'std::string') %}
  {% set delim = ',' %}
  {% if loop.last %}
  {% set delim = '' %}
  {% endif %}
  {% if (cpp_type != 'std::string') or string_key %}
    _o->{{member}}{{delim}}
  {% else %}
    _o->{{member}}.size() ? _fbb.CreateValueString(_o->{{member}}) : 0{{delim}}
  {% endif %}
  {% endfor %}
  );
}

inline const {{table_name}} *Get{{table_name}}(const void *buf) { return flatbuffers::GetRoot<{{table_name}}>(buf); }

inline {{table_name}} *GetMutable{{table_name}}(void *buf) { return flatbuffers::GetMutableRoot<{{table_name}}>(buf); }

inline bool Verify{{table_name}}Buffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<{{table_name}}>(nullptr); }

inline void Finish{{table_name}}Buffer(flatbuffers::KVStoreBuilder &fbb, flatbuffers::Offset<{{table_name}}> root) { fbb.Finish(root); }

{% endfor %}

}  // namespace {{namespace}}

