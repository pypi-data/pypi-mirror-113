{"version":3,"sources":["webpack:///./app/actionCreators/events.tsx","webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/utils/getPeriod.tsx"],"names":["doEventsRequest","api","organization","project","environment","team","period","start","end","interval","includePrevious","query","yAxis","field","topEvents","orderby","partial","shouldDoublePeriod","canIncludePreviousPeriod","urlQuery","Object","fromEntries","entries","undefined","filter","periodObj","getPeriod","requestPromise","slug","fetchTagFacets","orgSlug","urlParams","pick","values","PERFORMANCE_URL_PARAM","queryOption","fetchTotalCount","then","res","count","propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","includes","EventsRequest","reloading","loading","errored","timeseriesData","fetchedWithPrevious","confirmedQuery","expired","name","hideError","setState","state","addErrorMessage","t","append","clear","responseJSON","detail","unmounting","data","hasPreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","previous","this","fetchData","prevProps","isEqual","getName","timestamp","map","i","countArray","value","reduce","acc","seriesName","previousSeriesName","calculateTotalsPerTimestamp","_timestamp","_countArray","response","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","getData","transformTimeseriesData","currentSeriesName","allData","originalData","originalPreviousData","previousData","transformPreviousPeriodData","timeAggregatedData","transformAggregatedTimeseries","children","showLoading","isMultiSeriesStats","results","keys","seriesData","transformed","order","sort","a","b","item","processData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","previousTimeseriesData","React","limit","DEFAULT_STATS_PERIOD","statsPeriod","match","periodNumber","periodLength","parseInt","Error","formattedStart","getUtcDateString","formattedEnd","diff","moment","previousPeriodStart","subtract"],"mappings":"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","file":"chunks/app_components_charts_eventsRequest_tsx.xxxxxxxxxxxxxxxxxxxx.js","sourcesContent":["import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {Client} from 'app/api';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {\n  DateString,\n  EventsStats,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {LocationQuery} from 'app/utils/discover/eventView';\nimport {getPeriod} from 'app/utils/getPeriod';\nimport {PERFORMANCE_URL_PARAM} from 'app/utils/performance/constants';\n\ntype Options = {\n  organization: OrganizationSummary;\n  project?: Readonly<number[]>;\n  environment?: Readonly<string[]>;\n  team?: Readonly<string | string[]>;\n  period?: string;\n  start?: DateString;\n  end?: DateString;\n  interval?: string;\n  includePrevious?: boolean;\n  limit?: number;\n  query?: string;\n  yAxis?: string | string[];\n  field?: string[];\n  topEvents?: number;\n  orderby?: string;\n  partial: boolean;\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {String[]} options.team List of teams to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n */\nexport const doEventsRequest = (\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    team,\n    period,\n    start,\n    end,\n    interval,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n    partial,\n  }: Options\n): Promise<EventsStats | MultiSeriesEventsStats> => {\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      project,\n      environment,\n      team,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n      partial: partial ? '1' : undefined,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  return api.requestPromise(`/organizations/${organization.slug}/events-stats/`, {\n    query: {\n      ...urlQuery,\n      ...periodObj,\n    },\n  });\n};\n\nexport type EventQuery = {\n  field: string[];\n  equation?: string[];\n  team?: string | string[];\n  project?: string | string[];\n  sort?: string | string[];\n  query: string;\n  per_page?: number;\n  referrer?: string;\n  environment?: string[];\n  noPagination?: boolean;\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  value: string;\n  url: LocationDescriptor;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport async function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(PERFORMANCE_URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport async function fetchTotalCount(\n  api: Client,\n  orgSlug: String,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(PERFORMANCE_URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n","import * as React from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\n\nimport {doEventsRequest} from 'app/actionCreators/events';\nimport {addErrorMessage} from 'app/actionCreators/indicator';\nimport {Client} from 'app/api';\nimport LoadingPanel from 'app/components/charts/loadingPanel';\nimport {canIncludePreviousPeriod, isMultiSeriesStats} from 'app/components/charts/utils';\nimport {t} from 'app/locale';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {Series, SeriesDataUnit} from 'app/types/echarts';\n\nexport type TimeSeriesData = {\n  // timeseries data\n  timeseriesData?: Series[];\n  allTimeseriesData?: EventsStatsData;\n  originalTimeseriesData?: EventsStatsData;\n  timeseriesTotals?: {count: number};\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  previousTimeseriesData?: Series | null;\n  timeAggregatedData?: Series | {};\n};\n\ntype LoadingStatus = {\n  loading: boolean;\n  reloading: boolean;\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n};\n\n// Chart format for multiple series.\ntype MultiSeriesResults = Series[];\n\ntype RenderProps = LoadingStatus & TimeSeriesData & {results?: MultiSeriesResults};\n\ntype DefaultProps = {\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  organization: OrganizationSummary;\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * List of team ids to query\n   */\n  team?: Readonly<string | string[]>;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n  /**\n   * Name used for display current series data set tooltip\n   */\n  currentSeriesName?: string;\n  previousSeriesName?: string;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n  /**\n   * Is query out of retention\n   */\n  expired?: boolean;\n  /**\n   * Query name used for displaying error toast if it is out of retention\n   */\n  name?: string;\n  /**\n   * Whether or not to include the last partial bucket. This happens for example when the\n   * current time is 11:26 and the last bucket ranges from 11:25-11:30. This means that\n   * the last bucket contains 1 minute worth of data while the rest contains 5 minutes.\n   *\n   * This flag indicates whether or not this last bucket should be included in the result.\n   */\n  partial: boolean;\n  /**\n   * Hide error toast (used for pages which also query eventsV2)\n   */\n  hideError?: boolean;\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\ntype EventsRequestProps = DefaultProps & TimeAggregationProps & EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  reloading: boolean;\n  errored: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  fetchedWithPrevious: boolean;\n};\n\nconst propNamesToIgnore = ['api', 'children', 'organization', 'loading'];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends React.PureComponent<EventsRequestProps, EventsRequestState> {\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, expired, name, hideError, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n    }));\n\n    if (expired) {\n      addErrorMessage(\n        t('%s has an invalid date range. Please try a more recent date range.', name),\n        {append: true}\n      );\n\n      this.setState({\n        errored: true,\n      });\n    } else {\n      try {\n        api.clear();\n        timeseriesData = await doEventsRequest(api, props);\n      } catch (resp) {\n        if (!hideError) {\n          if (resp && resp.responseJSON && resp.responseJSON.detail) {\n            addErrorMessage(resp.responseJSON.detail);\n          } else {\n            addErrorMessage(t('Error loading chart data'));\n          }\n        }\n        this.setState({\n          errored: true,\n        });\n      }\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n  };\n\n  /**\n   * Retrieves data set for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData\n  ): {previous: EventsStatsData | null; current: EventsStatsData} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: this.props.previousSeriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(data: EventsStatsData, seriesName?: string): Series[] {\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats | null) {\n    if (!response) {\n      return {};\n    }\n\n    const {data, totals} = response;\n    const {includeTransformedData, includeTimeAggregation, timeAggregationSeriesName} =\n      this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(current, this.props.currentSeriesName)\n      : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(current, previous)\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    return {\n      data: transformedData,\n      allData: data,\n      originalData: current,\n      totals,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n    };\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {timeseriesData, reloading, errored} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n\n    if (isMultiSeriesStats(timeseriesData)) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      const results: MultiSeriesResults = Object.keys(timeseriesData)\n        .map((seriesName: string): [number, Series] => {\n          const seriesData: EventsStats = timeseriesData[seriesName];\n          const transformed = this.transformTimeseriesData(\n            seriesData.data,\n            seriesName\n          )[0];\n          return [seriesData.order || 0, transformed];\n        })\n        .sort((a, b) => a[0] - b[0])\n        .map(item => item[1]);\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        results,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n\n    const {\n      data: transformedTimeseriesData,\n      allData: allTimeseriesData,\n      originalData: originalTimeseriesData,\n      totals: timeseriesTotals,\n      originalPreviousData: originalPreviousTimeseriesData,\n      previousData: previousTimeseriesData,\n      timeAggregatedData,\n    } = this.processData(timeseriesData);\n\n    return children({\n      loading,\n      reloading,\n      errored,\n      // timeseries data\n      timeseriesData: transformedTimeseriesData,\n      allTimeseriesData,\n      originalTimeseriesData,\n      timeseriesTotals,\n      originalPreviousTimeseriesData,\n      previousTimeseriesData,\n      timeAggregatedData,\n      // sometimes we want to reference props that were given to EventsRequest\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'app/constants';\nimport {getUtcDateString} from 'app/utils/dates';\n\ntype DateObject = {\n  /**\n   * Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n   */\n  period?: string;\n  /**\n   * Starting date object\n   */\n  start?: string | Date | null;\n  /**\n   * Ending date object\n   */\n  end?: string | Date | null;\n};\n\ntype Options = {\n  /**\n   * Doubles the given period (useful for getting previous period data)\n   */\n  shouldDoublePeriod?: boolean;\n};\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\nexport const getPeriod = (\n  {period, start, end}: DateObject,\n  {shouldDoublePeriod}: Options = {}\n) => {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/)!;\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n};\n"],"sourceRoot":""}