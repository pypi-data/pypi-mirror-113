{"version":3,"sources":["webpack:///./app/actions/groupingActions.tsx","webpack:///./app/stores/groupingStore.tsx","webpack:///./app/views/organizationGroupDetails/groupMerged/mergedItem.tsx","webpack:///./app/views/organizationGroupDetails/groupMerged/mergedToolbar.tsx","webpack:///./app/views/organizationGroupDetails/groupMerged/mergedList.tsx","webpack:///./app/views/organizationGroupDetails/groupMerged/index.tsx"],"names":["GroupingActions","Reflux","storeConfig","listenables","api","Client","init","state","this","getInitialState","Object","entries","forEach","key","value","mergedItems","unmergeList","Map","unmergeState","unmergeDisabled","unmergeLastCollapsed","enableFingerprintCompare","similarItems","filteredSimilarItems","similarLinks","mergeState","mergeList","mergedLinks","mergeDisabled","loading","error","setStateForId","map","idOrIds","newState","Array","isArray","id","mergedState","has","get","set","isAllUnmergedSelected","lockedItems","from","values","filter","busy","size","latestEvent","length","onFetch","toFetchArray","requests","triggerFetchState","promises","endpoint","queryParams","dataKey","Promise","resolve","reject","request","method","data","success","_","jqXHR","links","getResponseHeader","err","responseJSON","detail","responseProcessors","merged","items","newItemsMap","newItems","item","newItem","eventCount","children","push","childId","childLabel","lastSeen","similar","issue","scoreMap","isBelowThreshold","scores","keys","find","score","checkBelowThreshold","scoresByInterface","scoreKey","reduce","acc","String","split","interfaceName","aggregate","avg","sum","all","then","resultsArray","onToggleMerge","checked","undefined","includes","triggerMergeState","onToggleUnmerge","fingerprint","eventId","delete","triggerUnmergeState","onUnmerge","groupId","loadingMessage","successMessage","errorMessage","ids","Error","addLoadingMessage","query","addSuccessMessage","clear","addErrorMessage","complete","onMerge","params","projectId","orgId","mergeGroups","itemIds","merge","parent","trigger","mergedParent","onToggleCollapseFingerprints","collapsed","onToggleCollapseFingerprint","pick","GroupingStore","MergedItem","onGroupChange","props","stateForId","setState","prevState","event","preventDefault","label","title","organization","checkboxDisabled","MergedGroup","Controls","expanded","ActionWrapper","onClick","handleToggle","disabled","onChange","handleCheckClick","FingerprintLabel","handleLabelClick","htmlFor","renderFingerprint","Collapse","handleToggleEvents","direction","MergedEventList","className","EventDetails","hideIcons","hideLevel","React","p","space","theme","innerBorder","gray100","text","familyMono","MergedToolbar","updateObj","project","baseEventId","targetEventId","openDiffModal","targetIssueId","baseIssueId","stopPropagation","listener","onToggleCollapse","unmergeCount","hasButtons","onConfirm","message","t","tct","CompareButton","handleShowDiff","Button","MergedList","fingerprints","pageLinks","fingerprintsWithLatestEvent","Fragment","count","slug","withOrganization","GroupMergedView","location","onGroupingChange","getEndpoint","fetchData","nextProps","search","callIfFunction","limit","queryString","isLoading","isError","isLoadedSuccessfully","type","onRetry","handleUnmerge","Component"],"mappings":"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","file":"chunks/app_views_organizationGroupDetails_groupMerged_index_tsx.xxxxxxxxxxxxxxxxxxxx.js","sourcesContent":["import Reflux from 'reflux';\n\n// Actions for \"Grouping\" view - for merging/unmerging events/issues\nconst GroupingActions = Reflux.createActions([\n  'fetch',\n  'showAllSimilarItems',\n  'toggleUnmerge',\n  'toggleMerge',\n  'unmerge',\n  'merge',\n  'toggleCollapseFingerprint',\n  'toggleCollapseFingerprints',\n]);\nexport default GroupingActions;\n","import pick from 'lodash/pick';\nimport Reflux from 'reflux';\n\nimport {mergeGroups} from 'app/actionCreators/group';\nimport {\n  addErrorMessage,\n  addLoadingMessage,\n  addSuccessMessage,\n} from 'app/actionCreators/indicator';\nimport GroupingActions from 'app/actions/groupingActions';\nimport {Client} from 'app/api';\nimport {Group, Organization, Project} from 'app/types';\nimport {Event} from 'app/types/event';\n\n// Between 0-100\nconst MIN_SCORE = 0.6;\n\n// @param score: {[key: string]: number}\nconst checkBelowThreshold = (scores = {}) => {\n  const scoreKeys = Object.keys(scores);\n  return !scoreKeys.map(key => scores[key]).find(score => score >= MIN_SCORE);\n};\n\ntype State = {\n  // List of fingerprints that belong to issue\n  mergedItems: [];\n  // Map of {[fingerprint]: Array<fingerprint, event id>} that is selected to be unmerged\n  unmergeList: Map<any, any>;\n  // Map of state for each fingerprint (i.e. \"collapsed\")\n  unmergeState: Map<any, any>;\n  // Disabled state of \"Unmerge\" button in \"Merged\" tab (for Issues)\n  unmergeDisabled: boolean;\n  // If \"Collapse All\" was just used, this will be true\n  unmergeLastCollapsed: boolean;\n  // \"Compare\" button state\n  enableFingerprintCompare: boolean;\n  similarItems: [];\n  filteredSimilarItems: [];\n  similarLinks: string;\n  mergeState: Map<any, any>;\n  mergeList: Array<string>;\n  mergedLinks: string;\n  mergeDisabled: boolean;\n  loading: boolean;\n  error: boolean;\n};\n\ntype ScoreMap = Record<string, number | null>;\n\ntype ApiFingerprint = {\n  id: string;\n  latestEvent: Event;\n  state?: string;\n  lastSeen?: string;\n  eventCount?: number;\n  parentId?: string;\n  label?: string;\n  parentLabel?: string;\n  childId?: string;\n  childLabel?: string;\n};\n\ntype ChildFingerprint = {\n  childId: string;\n  childLabel?: string;\n  eventCount?: number;\n  lastSeen?: string;\n  latestEvent?: Event;\n};\n\nexport type Fingerprint = {\n  id: string;\n  latestEvent: Event;\n  eventCount: number;\n  children: Array<ChildFingerprint>;\n  state?: string;\n  lastSeen?: string;\n  parentId?: string;\n  label?: string;\n  parentLabel?: string;\n};\n\ntype ResponseProcessors = {\n  merged: (item: ApiFingerprint[]) => Fingerprint[];\n  similar: (data: [Group, ScoreMap]) => {\n    issue: Group;\n    score: ScoreMap;\n    scoresByInterface: Record<string, Array<[string, number | null]>>;\n    aggregate: Record<string, number>;\n    isBelowThreshold: boolean;\n  };\n};\n\ntype DataKey = keyof ResponseProcessors;\n\ntype ResultsAsArrayDataMerged = Parameters<ResponseProcessors['merged']>[0];\n\ntype ResultsAsArrayDataSimilar = Array<Parameters<ResponseProcessors['similar']>[0]>;\n\ntype ResultsAsArray = Array<{\n  dataKey: DataKey;\n  data: ResultsAsArrayDataMerged | ResultsAsArrayDataSimilar;\n  links: string | null;\n}>;\n\ntype IdState = {\n  busy?: boolean;\n  checked?: boolean;\n  collapsed?: boolean;\n};\n\ntype GroupingStoreInterface = Reflux.StoreDefinition & {\n  init: () => void;\n  getInitialState: () => State;\n  setStateForId: (\n    map: Map<string, IdState>,\n    idOrIds: Array<string> | string,\n    newState: IdState\n  ) => Array<IdState>;\n  isAllUnmergedSelected: () => boolean;\n  onFetch: (\n    toFetchArray?: Array<{\n      dataKey: DataKey;\n      endpoint: string;\n      queryParams?: Record<string, any>;\n    }>\n  ) => Promise<any>;\n  onToggleMerge: (id: string) => void;\n  onToggleUnmerge: (props: [string, string] | string) => void;\n  onUnmerge: (props: {\n    groupId: Group['id'];\n    loadingMessage?: string;\n    successMessage?: string;\n    errorMessage?: string;\n  }) => void;\n  onMerge: (props: {\n    params?: {\n      orgId: Organization['id'];\n      projectId: Project['id'];\n      groupId: Group['id'];\n    };\n    projectId?: Project['id'];\n    query?: string;\n  }) => undefined | Promise<any>;\n  onToggleCollapseFingerprints: () => void;\n  onToggleCollapseFingerprint: (fingerprint: string) => void;\n  triggerFetchState: () => Pick<\n    State,\n    | 'similarItems'\n    | 'filteredSimilarItems'\n    | 'mergedItems'\n    | 'mergedLinks'\n    | 'similarLinks'\n    | 'mergeState'\n    | 'unmergeState'\n    | 'loading'\n    | 'error'\n  >;\n  triggerUnmergeState: () => Pick<\n    State,\n    | 'unmergeDisabled'\n    | 'unmergeState'\n    | 'unmergeList'\n    | 'enableFingerprintCompare'\n    | 'unmergeLastCollapsed'\n  >;\n  triggerMergeState: () => Pick<State, 'mergeState' | 'mergeDisabled' | 'mergeList'>;\n};\n\ntype Internals = {\n  api: Client;\n};\n\ntype GroupingStore = Reflux.Store & GroupingStoreInterface;\n\nconst storeConfig: Reflux.StoreDefinition & Internals & GroupingStoreInterface = {\n  listenables: [GroupingActions],\n  api: new Client(),\n\n  init() {\n    const state = this.getInitialState();\n\n    Object.entries(state).forEach(([key, value]) => {\n      this[key] = value;\n    });\n  },\n\n  getInitialState() {\n    return {\n      // List of fingerprints that belong to issue\n      mergedItems: [],\n      // Map of {[fingerprint]: Array<fingerprint, event id>} that is selected to be unmerged\n      unmergeList: new Map(),\n      // Map of state for each fingerprint (i.e. \"collapsed\")\n      unmergeState: new Map(),\n      // Disabled state of \"Unmerge\" button in \"Merged\" tab (for Issues)\n      unmergeDisabled: true,\n      // If \"Collapse All\" was just used, this will be true\n      unmergeLastCollapsed: false,\n      // \"Compare\" button state\n      enableFingerprintCompare: false,\n      similarItems: [],\n      filteredSimilarItems: [],\n      similarLinks: '',\n      mergeState: new Map(),\n      mergeList: [],\n      mergedLinks: '',\n      mergeDisabled: false,\n      loading: true,\n      error: false,\n    };\n  },\n\n  setStateForId(map, idOrIds, newState) {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    return ids.map(id => {\n      const state = (map.has(id) && map.get(id)) || {};\n      const mergedState = {...state, ...newState};\n      map.set(id, mergedState);\n      return mergedState;\n    });\n  },\n\n  isAllUnmergedSelected() {\n    const lockedItems =\n      (Array.from(this.unmergeState.values()) as Array<IdState>).filter(\n        ({busy}) => busy\n      ) || [];\n    return (\n      this.unmergeList.size ===\n      this.mergedItems.filter(({latestEvent}) => !!latestEvent).length -\n        lockedItems.length\n    );\n  },\n\n  // Fetches data\n  onFetch(toFetchArray) {\n    const requests = toFetchArray || this.toFetchArray;\n\n    // Reset state and trigger update\n    this.init();\n    this.triggerFetchState();\n\n    const promises = requests.map(\n      ({endpoint, queryParams, dataKey}) =>\n        new Promise((resolve, reject) => {\n          this.api.request(endpoint, {\n            method: 'GET',\n            data: queryParams,\n            success: (data, _, jqXHR) => {\n              resolve({\n                dataKey,\n                data,\n                links: jqXHR ? jqXHR.getResponseHeader('Link') : null,\n              });\n            },\n            error: err => {\n              const error = err.responseJSON?.detail || true;\n              reject(error);\n            },\n          });\n        })\n    );\n\n    const responseProcessors: ResponseProcessors = {\n      merged: items => {\n        const newItemsMap: Record<string, Fingerprint> = {};\n        const newItems: Fingerprint[] = [];\n\n        items.forEach(item => {\n          if (!newItemsMap[item.id]) {\n            const newItem = {\n              eventCount: 0,\n              children: [],\n              // lastSeen and latestEvent properties are correct\n              // since the server returns items in\n              // descending order of lastSeen\n              ...item,\n            };\n            // Check for locked items\n            this.setStateForId(this.unmergeState, item.id, {\n              busy: item.state === 'locked',\n            });\n\n            newItemsMap[item.id] = newItem;\n            newItems.push(newItem);\n          }\n\n          const newItem = newItemsMap[item.id];\n          const {childId, childLabel, eventCount, lastSeen, latestEvent} = item;\n\n          if (eventCount) {\n            newItem.eventCount += eventCount;\n          }\n\n          if (childId) {\n            newItem.children.push({\n              childId,\n              childLabel,\n              lastSeen,\n              latestEvent,\n              eventCount,\n            });\n          }\n        });\n\n        return newItems;\n      },\n      similar: ([issue, scoreMap]) => {\n        // Hide items with a low scores\n        const isBelowThreshold = checkBelowThreshold(scoreMap);\n\n        // List of scores indexed by interface (i.e., exception and message)\n        // Note: for v2, the interface is always \"similarity\". When v2 is\n        // rolled out we can get rid of this grouping entirely.\n        const scoresByInterface = Object.keys(scoreMap)\n          .map(scoreKey => [scoreKey, scoreMap[scoreKey]])\n          .reduce((acc, [scoreKey, score]) => {\n            // v1 layout: '<interface>:...'\n            const [interfaceName] = String(scoreKey).split(':');\n\n            if (!acc[interfaceName]) {\n              acc[interfaceName] = [];\n            }\n            acc[interfaceName].push([scoreKey, score]);\n\n            return acc;\n          }, {});\n\n        // Aggregate score by interface\n        const aggregate = Object.keys(scoresByInterface)\n          .map(interfaceName => [interfaceName, scoresByInterface[interfaceName]])\n          .reduce((acc, [interfaceName, allScores]) => {\n            // `null` scores means feature was not present in both issues, do not\n            // include in aggregate\n            const scores = allScores.filter(([, score]) => score !== null);\n\n            const avg = scores.reduce((sum, [, score]) => sum + score, 0) / scores.length;\n\n            acc[interfaceName] = avg;\n            return acc;\n          }, {});\n\n        return {\n          issue,\n          score: scoreMap,\n          scoresByInterface,\n          aggregate,\n          isBelowThreshold,\n        };\n      },\n    };\n\n    if (toFetchArray) {\n      this.toFetchArray = toFetchArray;\n    }\n\n    return Promise.all(promises).then(\n      resultsArray => {\n        (resultsArray as ResultsAsArray).forEach(({dataKey, data, links}) => {\n          const items =\n            dataKey === 'similar'\n              ? (data as ResultsAsArrayDataSimilar).map(responseProcessors[dataKey])\n              : responseProcessors[dataKey](data as ResultsAsArrayDataMerged);\n\n          this[`${dataKey}Items`] = items;\n          this[`${dataKey}Links`] = links;\n        });\n\n        this.loading = false;\n        this.error = false;\n        this.triggerFetchState();\n      },\n      () => {\n        this.loading = false;\n        this.error = true;\n        this.triggerFetchState();\n      }\n    );\n  },\n\n  // Toggle merge checkbox\n  onToggleMerge(id) {\n    let checked = false;\n\n    // Don't do anything if item is busy\n    const state = this.mergeState.has(id) ? this.mergeState.get(id) : undefined;\n\n    if (state?.busy === true) {\n      return;\n    }\n\n    if (this.mergeList.includes(id)) {\n      this.mergeList = this.mergeList.filter(item => item !== id);\n    } else {\n      this.mergeList = [...this.mergeList, id];\n      checked = true;\n    }\n\n    this.setStateForId(this.mergeState, id, {\n      checked,\n    });\n\n    this.triggerMergeState();\n  },\n\n  // Toggle unmerge check box\n  onToggleUnmerge([fingerprint, eventId]) {\n    let checked = false;\n\n    // Uncheck an item to unmerge\n    const state = this.unmergeState.get(fingerprint);\n\n    if (state?.busy === true) {\n      return;\n    }\n\n    if (this.unmergeList.has(fingerprint)) {\n      this.unmergeList.delete(fingerprint);\n    } else {\n      this.unmergeList.set(fingerprint, eventId);\n      checked = true;\n    }\n\n    // Update \"checked\" state for row\n    this.setStateForId(this.unmergeState, fingerprint, {\n      checked,\n    });\n\n    // Unmerge should be disabled if 0 or all items are selected, or if there's\n    // only one item to select\n    this.unmergeDisabled =\n      this.mergedItems.size <= 1 ||\n      this.unmergeList.size === 0 ||\n      this.isAllUnmergedSelected();\n    this.enableFingerprintCompare = this.unmergeList.size === 2;\n\n    this.triggerUnmergeState();\n  },\n\n  onUnmerge({groupId, loadingMessage, successMessage, errorMessage}) {\n    const ids = Array.from(this.unmergeList.keys()) as Array<string>;\n\n    return new Promise((resolve, reject) => {\n      if (this.isAllUnmergedSelected()) {\n        reject(new Error('Not allowed to unmerge ALL events'));\n        return;\n      }\n\n      // Disable unmerge button\n      this.unmergeDisabled = true;\n\n      // Disable rows\n      this.setStateForId(this.unmergeState, ids, {\n        checked: false,\n        busy: true,\n      });\n      this.triggerUnmergeState();\n      addLoadingMessage(loadingMessage);\n\n      this.api.request(`/issues/${groupId}/hashes/`, {\n        method: 'DELETE',\n        query: {\n          id: ids,\n        },\n        success: () => {\n          addSuccessMessage(successMessage);\n\n          // Busy rows after successful Unmerge\n          this.setStateForId(this.unmergeState, ids, {\n            checked: false,\n            busy: true,\n          });\n          this.unmergeList.clear();\n        },\n        error: () => {\n          addErrorMessage(errorMessage);\n          this.setStateForId(this.unmergeState, ids, {\n            checked: true,\n            busy: false,\n          });\n        },\n        complete: () => {\n          this.unmergeDisabled = false;\n          resolve(this.triggerUnmergeState());\n        },\n      });\n    });\n  },\n\n  // For cross-project views, we need to pass projectId instead of\n  // depending on router params (since we will only have orgId in that case)\n  onMerge({params, query, projectId}) {\n    if (!params) {\n      return undefined;\n    }\n\n    const ids = this.mergeList;\n\n    this.mergeDisabled = true;\n\n    this.setStateForId(this.mergeState, ids as Array<string>, {\n      busy: true,\n    });\n\n    this.triggerMergeState();\n\n    const promise = new Promise(resolve => {\n      // Disable merge button\n      const {orgId, groupId} = params;\n\n      mergeGroups(\n        this.api,\n        {\n          orgId,\n          projectId: projectId || params.projectId,\n          itemIds: [...ids, groupId] as Array<number>,\n          query,\n        },\n        {\n          success: data => {\n            if (data?.merge?.parent) {\n              this.trigger({\n                mergedParent: data.merge.parent,\n              });\n            }\n\n            // Hide rows after successful merge\n            this.setStateForId(this.mergeState, ids as Array<string>, {\n              checked: false,\n              busy: true,\n            });\n            this.mergeList = [];\n          },\n          error: () => {\n            this.setStateForId(this.mergeState, ids as Array<string>, {\n              checked: true,\n              busy: false,\n            });\n          },\n          complete: () => {\n            this.mergeDisabled = false;\n            resolve(this.triggerMergeState());\n          },\n        }\n      );\n    });\n\n    return promise;\n  },\n\n  // Toggle collapsed state of all fingerprints\n  onToggleCollapseFingerprints() {\n    this.setStateForId(\n      this.unmergeState,\n      this.mergedItems.map(({id}) => id),\n      {\n        collapsed: !this.unmergeLastCollapsed,\n      }\n    );\n\n    this.unmergeLastCollapsed = !this.unmergeLastCollapsed;\n\n    this.trigger({\n      unmergeLastCollapsed: this.unmergeLastCollapsed,\n      unmergeState: this.unmergeState,\n    });\n  },\n\n  onToggleCollapseFingerprint(fingerprint) {\n    const collapsed =\n      this.unmergeState.has(fingerprint) && this.unmergeState.get(fingerprint).collapsed;\n    this.setStateForId(this.unmergeState, fingerprint, {collapsed: !collapsed});\n    this.trigger({\n      unmergeState: this.unmergeState,\n    });\n  },\n\n  triggerFetchState() {\n    const state = {\n      similarItems: this.similarItems.filter(({isBelowThreshold}) => !isBelowThreshold),\n      filteredSimilarItems: this.similarItems.filter(\n        ({isBelowThreshold}) => isBelowThreshold\n      ),\n      ...pick(this, [\n        'mergedItems',\n        'mergedLinks',\n        'similarLinks',\n        'mergeState',\n        'unmergeState',\n        'loading',\n        'error',\n        'enableFingerprintCompare',\n        'unmergeList',\n      ]),\n    };\n    this.trigger(state);\n    return state;\n  },\n\n  triggerUnmergeState() {\n    const state = pick(this, [\n      'unmergeDisabled',\n      'unmergeState',\n      'unmergeList',\n      'enableFingerprintCompare',\n      'unmergeLastCollapsed',\n    ]);\n    this.trigger(state);\n    return state;\n  },\n\n  triggerMergeState() {\n    const state = pick(this, ['mergeDisabled', 'mergeState', 'mergeList']);\n    this.trigger(state);\n    return state;\n  },\n};\n\nconst GroupingStore = Reflux.createStore(storeConfig) as GroupingStore;\n\nexport default GroupingStore;\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nimport GroupingActions from 'app/actions/groupingActions';\nimport Checkbox from 'app/components/checkbox';\nimport EventOrGroupHeader from 'app/components/eventOrGroupHeader';\nimport Tooltip from 'app/components/tooltip';\nimport {IconChevron} from 'app/icons';\nimport GroupingStore, {Fingerprint} from 'app/stores/groupingStore';\nimport space from 'app/styles/space';\nimport {Organization} from 'app/types';\n\ntype Props = {\n  organization: Organization;\n  fingerprint: Fingerprint;\n};\n\ntype State = {\n  collapsed: boolean;\n  checked: boolean;\n  busy: boolean;\n};\n\nclass MergedItem extends React.Component<Props, State> {\n  state: State = {\n    collapsed: false,\n    checked: false,\n    busy: false,\n  };\n\n  listener = GroupingStore.listen(data => this.onGroupChange(data), undefined);\n\n  onGroupChange = ({unmergeState}) => {\n    if (!unmergeState) {\n      return;\n    }\n\n    const {fingerprint} = this.props;\n    const stateForId = unmergeState.has(fingerprint.id)\n      ? unmergeState.get(fingerprint.id)\n      : undefined;\n\n    if (!stateForId) {\n      return;\n    }\n\n    Object.keys(stateForId).forEach(key => {\n      if (stateForId[key] === this.state[key]) {\n        return;\n      }\n\n      this.setState(prevState => ({...prevState, [key]: stateForId[key]}));\n    });\n  };\n\n  handleToggleEvents = () => {\n    const {fingerprint} = this.props;\n    GroupingActions.toggleCollapseFingerprint(fingerprint.id);\n  };\n\n  // Disable default behavior of toggling checkbox\n  handleLabelClick(event: React.MouseEvent) {\n    event.preventDefault();\n  }\n\n  handleToggle = () => {\n    const {fingerprint} = this.props;\n    const {latestEvent} = fingerprint;\n\n    if (this.state.busy) {\n      return;\n    }\n\n    // clicking anywhere in the row will toggle the checkbox\n    GroupingActions.toggleUnmerge([fingerprint.id, latestEvent.id]);\n  };\n\n  handleCheckClick() {\n    // noop because of react warning about being a controlled input without `onChange`\n    // we handle change via row click\n  }\n\n  renderFingerprint(id: string, label?: string) {\n    if (!label) {\n      return id;\n    }\n\n    return (\n      <Tooltip title={id}>\n        <code>{label}</code>\n      </Tooltip>\n    );\n  }\n\n  render() {\n    const {fingerprint, organization} = this.props;\n    const {latestEvent, id, label} = fingerprint;\n    const {collapsed, busy, checked} = this.state;\n    const checkboxDisabled = busy;\n\n    // `latestEvent` can be null if last event w/ fingerprint is not within retention period\n    return (\n      <MergedGroup busy={busy}>\n        <Controls expanded={!collapsed}>\n          <ActionWrapper onClick={this.handleToggle}>\n            <Checkbox\n              id={id}\n              value={id}\n              checked={checked}\n              disabled={checkboxDisabled}\n              onChange={this.handleCheckClick}\n            />\n\n            <FingerprintLabel onClick={this.handleLabelClick} htmlFor={id}>\n              {this.renderFingerprint(id, label)}\n            </FingerprintLabel>\n          </ActionWrapper>\n\n          <div>\n            <Collapse onClick={this.handleToggleEvents}>\n              <IconChevron direction={collapsed ? 'down' : 'up'} size=\"xs\" />\n            </Collapse>\n          </div>\n        </Controls>\n\n        {!collapsed && (\n          <MergedEventList className=\"event-list\">\n            {latestEvent && (\n              <EventDetails className=\"event-details\">\n                <EventOrGroupHeader\n                  data={latestEvent}\n                  organization={organization}\n                  hideIcons\n                  hideLevel\n                />\n              </EventDetails>\n            )}\n          </MergedEventList>\n        )}\n      </MergedGroup>\n    );\n  }\n}\n\nconst MergedGroup = styled('div')<{busy: boolean}>`\n  ${p => p.busy && 'opacity: 0.2'};\n`;\n\nconst ActionWrapper = styled('div')`\n  display: grid;\n  grid-auto-flow: column;\n  align-items: center;\n  gap: ${space(1)};\n\n  /* Can't use styled components for this because of broad selector */\n  input[type='checkbox'] {\n    margin: 0;\n  }\n`;\n\nconst Controls = styled('div')<{expanded: boolean}>`\n  display: flex;\n  justify-content: space-between;\n  border-top: 1px solid ${p => p.theme.innerBorder};\n  background-color: ${p => p.theme.gray100};\n  padding: ${space(0.5)} ${space(1)};\n  ${p => p.expanded && `border-bottom: 1px solid ${p.theme.innerBorder}`};\n\n  ${MergedGroup} {\n    &:first-child & {\n      border-top: none;\n    }\n    &:last-child & {\n      border-top: none;\n      border-bottom: 1px solid ${p => p.theme.innerBorder};\n    }\n  }\n`;\n\nconst FingerprintLabel = styled('label')`\n  font-family: ${p => p.theme.text.familyMono};\n\n  ${/* sc-selector */ Controls} & {\n    font-weight: 400;\n    margin: 0;\n  }\n`;\n\nconst Collapse = styled('span')`\n  cursor: pointer;\n`;\n\nconst MergedEventList = styled('div')`\n  overflow: hidden;\n  border: none;\n`;\n\nconst EventDetails = styled('div')`\n  display: flex;\n  justify-content: space-between;\n\n  .event-list & {\n    padding: ${space(1)};\n  }\n`;\n\nexport default MergedItem;\n","import * as React from 'react';\nimport styled from '@emotion/styled';\nimport pick from 'lodash/pick';\n\nimport {openDiffModal} from 'app/actionCreators/modal';\nimport Button from 'app/components/button';\nimport Confirm from 'app/components/confirm';\nimport {PanelHeader} from 'app/components/panels';\nimport {t, tct} from 'app/locale';\nimport GroupingStore from 'app/stores/groupingStore';\nimport space from 'app/styles/space';\nimport {Group, Organization, Project} from 'app/types';\n\ntype Props = {\n  orgId: Organization['slug'];\n  project: Project;\n  groupId: Group['id'];\n  onUnmerge: () => void;\n  onToggleCollapse: () => void;\n};\n\ntype State = {\n  unmergeList: Map<any, any>;\n  unmergeLastCollapsed: boolean;\n  unmergeDisabled: boolean;\n  enableFingerprintCompare: boolean;\n};\n\nclass MergedToolbar extends React.Component<Props, State> {\n  state: State = this.getInitialState();\n\n  getInitialState() {\n    const {unmergeList, unmergeLastCollapsed, unmergeDisabled, enableFingerprintCompare} =\n      GroupingStore;\n\n    return {\n      enableFingerprintCompare,\n      unmergeList,\n      unmergeLastCollapsed,\n      unmergeDisabled,\n    };\n  }\n\n  componentWillUnmount() {\n    this.listener?.();\n  }\n\n  listener = GroupingStore.listen(data => this.onGroupChange(data), undefined);\n\n  onGroupChange = updateObj => {\n    const allowedKeys = [\n      'unmergeLastCollapsed',\n      'unmergeDisabled',\n      'unmergeList',\n      'enableFingerprintCompare',\n    ];\n\n    this.setState(pick(updateObj, allowedKeys));\n  };\n\n  handleShowDiff = (event: React.MouseEvent) => {\n    const {groupId, project, orgId} = this.props;\n    const {unmergeList} = this.state;\n\n    const entries = unmergeList.entries();\n\n    // `unmergeList` should only have 2 items in map\n    if (unmergeList.size !== 2) {\n      return;\n    }\n\n    // only need eventId, not fingerprint\n    const [baseEventId, targetEventId] = Array.from(entries).map(\n      ([, eventId]) => eventId\n    );\n\n    openDiffModal({\n      targetIssueId: groupId,\n      project,\n      baseIssueId: groupId,\n      orgId,\n      baseEventId,\n      targetEventId,\n    });\n\n    event.stopPropagation();\n  };\n\n  render() {\n    const {onUnmerge, onToggleCollapse} = this.props;\n\n    const {unmergeList, unmergeLastCollapsed, unmergeDisabled, enableFingerprintCompare} =\n      this.state;\n    const unmergeCount = (unmergeList && unmergeList.size) || 0;\n\n    return (\n      <PanelHeader hasButtons>\n        <div>\n          <Confirm\n            disabled={unmergeDisabled}\n            onConfirm={onUnmerge}\n            message={t(\n              'These events will be unmerged and grouped into a new issue. Are you sure you want to unmerge these events?'\n            )}\n          >\n            <Button\n              size=\"small\"\n              title={tct('Unmerging [unmergeCount] events', {unmergeCount})}\n            >\n              {t('Unmerge')} ({unmergeCount || 0})\n            </Button>\n          </Confirm>\n\n          <CompareButton\n            size=\"small\"\n            disabled={!enableFingerprintCompare}\n            onClick={this.handleShowDiff}\n          >\n            {t('Compare')}\n          </CompareButton>\n        </div>\n        <Button size=\"small\" onClick={onToggleCollapse}>\n          {unmergeLastCollapsed ? t('Expand All') : t('Collapse All')}\n        </Button>\n      </PanelHeader>\n    );\n  }\n}\n\nexport default MergedToolbar;\n\nconst CompareButton = styled(Button)`\n  margin-left: ${space(1)};\n`;\n","import {Fragment} from 'react';\n\nimport EmptyStateWarning from 'app/components/emptyStateWarning';\nimport Pagination from 'app/components/pagination';\nimport {Panel, PanelBody} from 'app/components/panels';\nimport QueryCount from 'app/components/queryCount';\nimport {t} from 'app/locale';\nimport {Fingerprint} from 'app/stores/groupingStore';\nimport {Group, Organization, Project} from 'app/types';\nimport withOrganization from 'app/utils/withOrganization';\n\nimport MergedItem from './mergedItem';\nimport MergedToolbar from './mergedToolbar';\n\ntype Props = {\n  /**\n   * From GroupMergedView -> handleUnmerge\n   */\n  onUnmerge: () => void;\n  /*\n   * From GroupingActions.toggleCollapseFingerprints\n   */\n  onToggleCollapse: () => void;\n  organization: Organization;\n  groupId: Group['id'];\n  project: Project;\n  fingerprints?: Fingerprint[];\n  pageLinks?: string;\n};\n\nfunction MergedList({\n  fingerprints = [],\n  pageLinks,\n  onToggleCollapse,\n  onUnmerge,\n  organization,\n  groupId,\n  project,\n}: Props) {\n  const fingerprintsWithLatestEvent = fingerprints.filter(\n    ({latestEvent}) => !!latestEvent\n  );\n  const hasResults = fingerprintsWithLatestEvent.length > 0;\n\n  if (!hasResults) {\n    return (\n      <Panel>\n        <EmptyStateWarning>\n          <p>{t(\"There don't seem to be any hashes for this issue.\")}</p>\n        </EmptyStateWarning>\n      </Panel>\n    );\n  }\n\n  return (\n    <Fragment>\n      <h2>\n        <span>{t('Merged fingerprints with latest event')}</span>{' '}\n        <QueryCount count={fingerprintsWithLatestEvent.length} />\n      </h2>\n\n      <Panel>\n        <MergedToolbar\n          onToggleCollapse={onToggleCollapse}\n          onUnmerge={onUnmerge}\n          orgId={organization.slug}\n          project={project}\n          groupId={groupId}\n        />\n\n        <PanelBody>\n          {fingerprintsWithLatestEvent.map(fingerprint => (\n            <MergedItem\n              key={fingerprint.id}\n              organization={organization}\n              fingerprint={fingerprint}\n            />\n          ))}\n        </PanelBody>\n      </Panel>\n      {pageLinks && <Pagination pageLinks={pageLinks} />}\n    </Fragment>\n  );\n}\n\nexport default withOrganization(MergedList);\n","import {Component, Fragment} from 'react';\nimport {RouteComponentProps} from 'react-router';\nimport * as queryString from 'query-string';\n\nimport GroupingActions from 'app/actions/groupingActions';\nimport Alert from 'app/components/alert';\nimport LoadingError from 'app/components/loadingError';\nimport LoadingIndicator from 'app/components/loadingIndicator';\nimport {t} from 'app/locale';\nimport GroupingStore, {Fingerprint} from 'app/stores/groupingStore';\nimport {Group, Organization, Project} from 'app/types';\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport withOrganization from 'app/utils/withOrganization';\n\nimport MergedList from './mergedList';\n\ntype Props = RouteComponentProps<\n  {groupId: Group['id']; orgId: Organization['slug']},\n  {}\n> & {\n  project: Project;\n  organization: Organization;\n};\n\ntype State = {\n  query: string;\n  loading: boolean;\n  error: boolean;\n  mergedItems: Array<Fingerprint>;\n  mergedLinks?: string;\n};\n\nclass GroupMergedView extends Component<Props, State> {\n  state: State = {\n    mergedItems: [],\n    loading: true,\n    error: false,\n    query: this.props.location.query.query || '',\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (\n      nextProps.params.groupId !== this.props.params.groupId ||\n      nextProps.location.search !== this.props.location.search\n    ) {\n      const queryParams = nextProps.location.query;\n      this.setState(\n        {\n          query: queryParams.query,\n        },\n        this.fetchData\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    callIfFunction(this.listener);\n  }\n\n  onGroupingChange = ({mergedItems, mergedLinks, loading, error}) => {\n    if (mergedItems) {\n      this.setState({\n        mergedItems,\n        mergedLinks,\n        loading: typeof loading !== 'undefined' ? loading : false,\n        error: typeof error !== 'undefined' ? error : false,\n      });\n    }\n  };\n\n  listener = GroupingStore.listen(this.onGroupingChange, undefined);\n\n  getEndpoint() {\n    const {params, location} = this.props;\n    const {groupId} = params;\n\n    const queryParams = {\n      ...location.query,\n      limit: 50,\n      query: this.state.query,\n    };\n\n    return `/issues/${groupId}/hashes/?${queryString.stringify(queryParams)}`;\n  }\n\n  fetchData = () => {\n    GroupingActions.fetch([\n      {\n        endpoint: this.getEndpoint(),\n        dataKey: 'merged',\n        queryParams: this.props.location.query,\n      },\n    ]);\n  };\n\n  handleUnmerge = () => {\n    GroupingActions.unmerge({\n      groupId: this.props.params.groupId,\n      loadingMessage: t('Unmerging events\\u2026'),\n      successMessage: t('Events successfully queued for unmerging.'),\n      errorMessage: t('Unable to queue events for unmerging.'),\n    });\n  };\n\n  render() {\n    const {project, params} = this.props;\n    const {groupId} = params;\n    const {loading: isLoading, error, mergedItems, mergedLinks} = this.state;\n    const isError = error && !isLoading;\n    const isLoadedSuccessfully = !isError && !isLoading;\n\n    return (\n      <Fragment>\n        <Alert type=\"warning\">\n          {t(\n            'This is an experimental feature. Data may not be immediately available while we process unmerges.'\n          )}\n        </Alert>\n\n        {isLoading && <LoadingIndicator />}\n        {isError && (\n          <LoadingError\n            message={t('Unable to load merged events, please try again later')}\n            onRetry={this.fetchData}\n          />\n        )}\n\n        {isLoadedSuccessfully && (\n          <MergedList\n            project={project}\n            fingerprints={mergedItems}\n            pageLinks={mergedLinks}\n            groupId={groupId}\n            onUnmerge={this.handleUnmerge}\n            onToggleCollapse={GroupingActions.toggleCollapseFingerprints}\n          />\n        )}\n      </Fragment>\n    );\n  }\n}\n\nexport {GroupMergedView};\n\nexport default withOrganization(GroupMergedView);\n"],"sourceRoot":""}