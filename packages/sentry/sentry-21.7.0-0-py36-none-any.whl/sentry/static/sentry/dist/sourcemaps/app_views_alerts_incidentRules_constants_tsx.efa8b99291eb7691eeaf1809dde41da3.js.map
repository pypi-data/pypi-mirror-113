{"version":3,"sources":["webpack:///./app/views/alerts/incidentRules/constants.tsx","webpack:///./app/views/alerts/utils/getIncidentDiscoverUrl.tsx","webpack:///./app/views/alerts/incidentRules/presets.tsx","webpack:///./app/views/alerts/incidentRules/types.tsx","webpack:///./app/views/alerts/types.tsx","webpack:///./app/views/alerts/utils/index.tsx"],"names":["DEFAULT_AGGREGATE","DEFAULT_TRANSACTION_AGGREGATE","DATASET_EVENT_TYPE_FILTERS","Dataset","DATASOURCE_EVENT_TYPE_FILTERS","Datasource","errorFieldConfig","aggregations","fields","commonAggregations","allAggregations","getWizardAlertFieldConfig","alertType","dataset","measurementKeys","Object","keys","WEB_VITAL_DETAILS","transactionFieldConfig","createDefaultTrigger","label","alertThreshold","actions","createDefaultRule","eventTypes","EventTypes","aggregate","query","timeWindow","triggers","projects","environment","resolveThreshold","thresholdType","AlertRuleThresholdType","createRuleFromEventView","eventView","parsedQuery","getQueryDatasource","datasetAndEventtypes","DATA_SOURCE_TO_SET_AND_EVENT_TYPES","source","getYAxis","length","createRuleFromWizardTemplate","wizardTemplate","aggregateDataset","getIncidentDiscoverUrl","opts","orgSlug","incident","stats","extraQueryParams","timeWindowString","alertRule","getStartEndFromStats","start","end","discoverQuery","id","undefined","name","title","orderby","getAggregateAlias","yAxis","filter","slug","includes","map","Number","version","EventView","getResultsViewUrlTarget","toObject","interval","PRESET_AGGREGATES","t","match","validDataset","default","makeCtaParams","makeDefaultCta","makeGenericTransactionCta","tooltip","to","buttonText","transaction","tokenizeSearch","getTagValues","find","display","DisplayModes","period","transactionSummaryRouteWithQuery","projectID","Set","TimePeriod","TimeWindow","ActionType","TargetType","ActionLabel","EMAIL","SLACK","PAGERDUTY","MSTEAMS","SENTRY_APP","TargetLabel","USER","TEAM","IncidentActivityType","IncidentStatus","IncidentStatusMethod","AlertRuleStatus","uncancellableApi","Client","fetchAlertRule","orgId","ruleId","requestPromise","fetchIncidentsForRule","includeSnapshots","expand","fetchIncident","api","alertId","fetchIncidentStats","updateSubscription","isSubscribed","method","updateStatus","status","data","isOpen","getIncidentMetricPreset","p","test","getUtcDateString","eventStats","isIssueAlert","hasOwnProperty","DATA_SOURCE_LABELS","convertDatasetEventTypesToSource","slice","sort","join","replace","trim","toUpperCase"],"mappings":"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","file":"chunks/app_views_alerts_incidentRules_constants_tsx.xxxxxxxxxxxxxxxxxxxx.js","sourcesContent":["import EventView from 'app/utils/discover/eventView';\nimport {AggregationKey, LooseFieldKey} from 'app/utils/discover/fields';\nimport {WEB_VITAL_DETAILS} from 'app/utils/performance/vitals/constants';\nimport {\n  AlertRuleThresholdType,\n  Dataset,\n  Datasource,\n  EventTypes,\n  Trigger,\n  UnsavedIncidentRule,\n} from 'app/views/alerts/incidentRules/types';\nimport {\n  DATA_SOURCE_TO_SET_AND_EVENT_TYPES,\n  getQueryDatasource,\n} from 'app/views/alerts/utils';\nimport {AlertType, WizardRuleTemplate} from 'app/views/alerts/wizard/options';\n\nexport const DEFAULT_AGGREGATE = 'count()';\nexport const DEFAULT_TRANSACTION_AGGREGATE = 'p95(transaction.duration)';\n\nexport const DATASET_EVENT_TYPE_FILTERS = {\n  [Dataset.ERRORS]: 'event.type:error',\n  [Dataset.TRANSACTIONS]: 'event.type:transaction',\n} as const;\n\nexport const DATASOURCE_EVENT_TYPE_FILTERS = {\n  [Datasource.ERROR_DEFAULT]: '(event.type:error OR event.type:default)',\n  [Datasource.ERROR]: 'event.type:error',\n  [Datasource.DEFAULT]: 'event.type:default',\n  [Datasource.TRANSACTION]: 'event.type:transaction',\n} as const;\n\nexport type OptionConfig = {\n  aggregations: AggregationKey[];\n  fields: LooseFieldKey[];\n  measurementKeys?: string[];\n};\n\n/**\n * Allowed error aggregations for alerts\n */\nexport const errorFieldConfig: OptionConfig = {\n  aggregations: ['count', 'count_unique'],\n  fields: ['user'],\n};\n\nconst commonAggregations: AggregationKey[] = [\n  'avg',\n  'percentile',\n  'p50',\n  'p75',\n  'p95',\n  'p99',\n  'p100',\n];\n\nconst allAggregations: AggregationKey[] = [\n  ...commonAggregations,\n  'failure_rate',\n  'apdex',\n  'count',\n];\n\nexport function getWizardAlertFieldConfig(\n  alertType: AlertType,\n  dataset: Dataset\n): OptionConfig {\n  if (alertType === 'custom' && dataset === Dataset.ERRORS) {\n    return errorFieldConfig;\n  }\n  // If user selected apdex we must include that in the OptionConfig as it has a user specified column\n  const aggregations =\n    alertType === 'apdex' || alertType === 'custom'\n      ? allAggregations\n      : commonAggregations;\n  return {\n    aggregations,\n    fields: ['transaction.duration'],\n    measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n  };\n}\n\n/**\n * Allowed aggregations for alerts created from wizard\n */\nexport const wizardAlertFieldConfig: OptionConfig = {\n  aggregations: commonAggregations,\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\n/**\n * Allowed transaction aggregations for alerts\n */\nexport const transactionFieldConfig: OptionConfig = {\n  aggregations: allAggregations,\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\nexport function createDefaultTrigger(label: 'critical' | 'warning'): Trigger {\n  return {\n    label,\n    alertThreshold: '',\n    actions: [],\n  };\n}\n\nexport function createDefaultRule(): UnsavedIncidentRule {\n  return {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n    aggregate: DEFAULT_AGGREGATE,\n    query: '',\n    timeWindow: 1,\n    triggers: [createDefaultTrigger('critical'), createDefaultTrigger('warning')],\n    projects: [],\n    environment: null,\n    resolveThreshold: '',\n    thresholdType: AlertRuleThresholdType.ABOVE,\n  };\n}\n\n/**\n * Create an unsaved alert from a discover EventView object\n */\nexport function createRuleFromEventView(eventView: EventView): UnsavedIncidentRule {\n  const parsedQuery = getQueryDatasource(eventView.query);\n  const datasetAndEventtypes = parsedQuery\n    ? DATA_SOURCE_TO_SET_AND_EVENT_TYPES[parsedQuery.source]\n    : DATA_SOURCE_TO_SET_AND_EVENT_TYPES.error;\n  return {\n    ...createDefaultRule(),\n    ...datasetAndEventtypes,\n    query: parsedQuery?.query ?? eventView.query,\n    // If creating a metric alert for transactions, default to the p95 metric\n    aggregate:\n      datasetAndEventtypes.dataset === 'transactions'\n        ? 'p95(transaction.duration)'\n        : eventView.getYAxis(),\n    environment: eventView.environment.length ? eventView.environment[0] : null,\n  };\n}\n\nexport function createRuleFromWizardTemplate(\n  wizardTemplate: WizardRuleTemplate\n): UnsavedIncidentRule {\n  const {eventTypes, ...aggregateDataset} = wizardTemplate;\n  return {\n    ...createDefaultRule(),\n    eventTypes: [eventTypes],\n    ...aggregateDataset,\n  };\n}\n","import {NewQuery, Project} from 'app/types';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {Dataset} from 'app/views/alerts/incidentRules/types';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n","import Link from 'app/components/links/link';\nimport {t} from 'app/locale';\nimport {Project} from 'app/types';\nimport {DisplayModes} from 'app/utils/discover/types';\nimport {tokenizeSearch} from 'app/utils/tokenizeSearch';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\nimport {getIncidentDiscoverUrl} from 'app/views/alerts/utils/getIncidentDiscoverUrl';\nimport {transactionSummaryRouteWithQuery} from 'app/views/performance/transactionSummary/utils';\n\nimport {Dataset} from './types';\n\ntype PresetCta = {\n  /**\n   * The location to direct to upon clicking the CTA.\n   */\n  to: React.ComponentProps<typeof Link>['to'];\n  /**\n   * The CTA text\n   */\n  buttonText: string;\n  /**\n   * The tooltip title for the CTA button, may be empty.\n   */\n  title?: string;\n};\n\ntype PresetCtaOpts = {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n};\n\ntype Preset = {\n  /**\n   * The regex used to match aggregates to this preset.\n   */\n  match: RegExp;\n  /**\n   * The name of the preset\n   */\n  name: string;\n  /**\n   * The dataset that this preset applys to.\n   */\n  validDataset: Dataset[];\n  /**\n   * The default aggregate to use when selecting this preset\n   */\n  default: string;\n  /**\n   * Generates the CTA component\n   */\n  makeCtaParams: (opts: PresetCtaOpts) => PresetCta;\n};\n\nexport const PRESET_AGGREGATES: Preset[] = [\n  {\n    name: t('Error count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count()',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Users affected'),\n    match: /^count_unique\\(tags\\[sentry:user\\]\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count_unique(tags[sentry:user])',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Latency'),\n    match: /^(p[0-9]{2,3}|percentile\\(transaction\\.duration,[^)]+\\)|avg\\([^)]+\\))/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'percentile(transaction.duration, 0.95)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Latency by Transaction'),\n      }),\n  },\n  {\n    name: t('Apdex'),\n    match: /^apdex\\([0-9.]+\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'apdex(300)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Apdex by Transaction'),\n      }),\n  },\n  {\n    name: t('Transaction Count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'count()',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts => makeGenericTransactionCta({opts}),\n  },\n  {\n    name: t('Failure rate'),\n    match: /^failure_rate\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'failure_rate()',\n    /**\n     * See makeFailureRateCta\n     */\n    makeCtaParams: makeFailureRateCta,\n  },\n];\n\n/**\n * - CASE 1: If has a specific transaction filter\n *   - CTA is: \"View Transaction Summary\"\n *   - Tooltip is the transaction name\n *   - the same period as the alert graph (i.e. with alert start time in the middle)\n *\n * - CASE 2: If transaction is NOT filtered, or has a * filter:\n *   - \"Open in Discover\" button with optional tooltip which opens a discover view with...\n *      - fields {transaction, count(), <metric>} sorted by count()\n *      - top-5 activated\n */\nfunction makeGenericTransactionCta(opts: {\n  opts: PresetCtaOpts;\n  tooltip?: string;\n}): PresetCta {\n  const {\n    opts: {orgSlug, projects, incident, stats},\n    tooltip,\n  } = opts;\n\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = tokenizeSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  // CASE 1\n  if (transaction !== undefined) {\n    const period = getStartEndFromStats(stats);\n\n    const summaryUrl = transactionSummaryRouteWithQuery({\n      orgSlug,\n      transaction,\n      projectID: projects\n        .filter(({slug}) => incident.projects.includes(slug))\n        .map(({id}) => id),\n      query: {...period},\n    });\n\n    return {\n      to: summaryUrl,\n      buttonText: t('View Transaction Summary'),\n      title: transaction,\n    };\n  }\n\n  // CASE 2\n  const extraQueryParams = {\n    fields: [...new Set(['transaction', 'count()', incident.alertRule.aggregate])],\n    orderby: '-count',\n    display: DisplayModes.TOP5,\n  };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: tooltip,\n  };\n}\n\n/**\n * - CASE 1: Filtered to a specific transaction, \"Open in Discover\" with...\n *   - fields [transaction.status, count()] sorted by count(),\n *   - \"Top 5 period\" activated.\n *\n * - CASE 2: If filtered on multiple transactions, \"Open in Discover\" button\n *   with tooltip \"Failure rate by transaction\" which opens a discover view\n *   - fields [transaction, failure_rate()] sorted by failure_rate\n *   - top 5 activated\n */\nfunction makeFailureRateCta({orgSlug, incident, projects, stats}: PresetCtaOpts) {\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = tokenizeSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  const extraQueryParams =\n    transaction !== undefined\n      ? // CASE 1\n        {\n          fields: ['transaction.status', 'count()'],\n          orderby: '-count',\n          display: DisplayModes.TOP5,\n        }\n      : // Case 2\n        {\n          fields: ['transaction', 'failure_rate()'],\n          orderby: '-failure_rate',\n          display: DisplayModes.TOP5,\n        };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: transaction === undefined ? t('Failure rate by transaction') : undefined,\n  };\n}\n\n/**\n * Get the CTA used for alerts that do not have a preset\n */\nexport function makeDefaultCta({\n  orgSlug,\n  projects,\n  incident,\n  stats,\n}: PresetCtaOpts): PresetCta {\n  if (!incident) {\n    return {\n      buttonText: t('Open in Discover'),\n      to: '',\n    };\n  }\n\n  const extraQueryParams = {\n    display: DisplayModes.TOP5,\n  };\n\n  return {\n    buttonText: t('Open in Discover'),\n    to: getIncidentDiscoverUrl({orgSlug, projects, incident, stats, extraQueryParams}),\n  };\n}\n","import {t} from 'app/locale';\n\nexport enum AlertRuleThresholdType {\n  ABOVE,\n  BELOW,\n}\n\nexport enum Dataset {\n  ERRORS = 'events',\n  TRANSACTIONS = 'transactions',\n}\n\nexport enum EventTypes {\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport enum Datasource {\n  ERROR_DEFAULT = 'error_default',\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport type UnsavedTrigger = {\n  // UnsavedTrigger can be apart of an Unsaved Alert Rule that does not have an\n  // id yet\n  alertRuleId?: string;\n  label: string;\n  alertThreshold: number | '' | null;\n  actions: Action[];\n};\n\nexport type ThresholdControlValue = {\n  thresholdType: AlertRuleThresholdType;\n  /**\n   * Resolve threshold is optional, so it can be null\n   */\n  threshold: number | '' | null;\n};\n\ntype SavedTrigger = Omit<UnsavedTrigger, 'actions'> & {\n  id: string;\n  dateCreated: string;\n  actions: Action[];\n};\n\nexport type Trigger = Partial<SavedTrigger> & UnsavedTrigger;\n\nexport type UnsavedIncidentRule = {\n  dataset: Dataset;\n  projects: string[];\n  environment: string | null;\n  query: string;\n  timeWindow: TimeWindow;\n  triggers: Trigger[];\n  aggregate: string;\n  thresholdType: AlertRuleThresholdType;\n  resolveThreshold: number | '' | null;\n  eventTypes?: EventTypes[];\n  owner?: string | null;\n};\n\nexport type SavedIncidentRule = UnsavedIncidentRule & {\n  dateCreated: string;\n  dateModified: string;\n  id: string;\n  status: number;\n  name: string;\n  createdBy?: {id: number; email: string; name: string} | null;\n  originalAlertRuleId?: number | null;\n};\n\nexport type IncidentRule = Partial<SavedIncidentRule> & UnsavedIncidentRule;\n\nexport enum TimePeriod {\n  SIX_HOURS = '6h',\n  ONE_DAY = '1d',\n  THREE_DAYS = '3d',\n  // Seven days is actually 10080m but we have a max of 10000 events\n  SEVEN_DAYS = '10000m',\n  FOURTEEN_DAYS = '14d',\n  THIRTY_DAYS = '30d',\n}\n\nexport enum TimeWindow {\n  ONE_MINUTE = 1,\n  FIVE_MINUTES = 5,\n  TEN_MINUTES = 10,\n  FIFTEEN_MINUTES = 15,\n  THIRTY_MINUTES = 30,\n  ONE_HOUR = 60,\n  TWO_HOURS = 120,\n  FOUR_HOURS = 240,\n  ONE_DAY = 1440,\n}\n\nexport enum ActionType {\n  EMAIL = 'email',\n  SLACK = 'slack',\n  PAGERDUTY = 'pagerduty',\n  MSTEAMS = 'msteams',\n  SENTRY_APP = 'sentry_app',\n}\n\nexport const ActionLabel = {\n  [ActionType.EMAIL]: t('Email'),\n  [ActionType.SLACK]: t('Slack'),\n  [ActionType.PAGERDUTY]: t('Pagerduty'),\n  [ActionType.MSTEAMS]: t('MS Teams'),\n  [ActionType.SENTRY_APP]: t('Notification'),\n};\n\nexport enum TargetType {\n  // A direct reference, like an email address, Slack channel, or PagerDuty service\n  SPECIFIC = 'specific',\n\n  // A specific user. This could be used to grab the user's email address.\n  USER = 'user',\n\n  // A specific team. This could be used to send an email to everyone associated with a team.\n  TEAM = 'team',\n\n  // A Sentry App instead of any of the above.\n  SENTRY_APP = 'sentry_app',\n}\n\nexport const TargetLabel = {\n  [TargetType.USER]: t('Member'),\n  [TargetType.TEAM]: t('Team'),\n};\n\n/**\n * This is an available action template that is associated to a Trigger in a\n * Metric Alert Rule. They are defined by the available-actions API.\n */\nexport type MetricActionTemplate = {\n  /**\n   * The integration type e.g. 'email'\n   */\n  type: ActionType;\n\n  /**\n   * See `TargetType`\n   */\n  allowedTargetTypes: TargetType[];\n\n  /**\n   * Name of the integration. This is a text field that differentiates integrations from the same provider from each other\n   */\n  integrationName?: string;\n\n  /**\n   * Integration id for this `type`, should be passed to backend as `integrationId` when creating an action\n   */\n  integrationId?: number;\n\n  /**\n   * Name of the SentryApp. Like `integrationName`, this differentiates SentryApps from each other.\n   */\n  sentryAppName?: string;\n\n  /**\n   * SentryApp id for this `type`, should be passed to backend as `sentryAppId` when creating an action.\n   */\n  sentryAppId?: number;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options?: Array<{label: string; value: any}>;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n\n/**\n * This is the user's configured action\n */\nexport type Action = UnsavedAction & Partial<SavedActionFields>;\nexport type SavedAction = Omit<UnsavedAction, 'unsavedDateCreated' | 'unsavedId'> &\n  SavedActionFields;\n\ntype SavedActionFields = {\n  /**\n   * The id of the alert rule this action belongs to\n   */\n  alertRuleTriggerId: string;\n\n  /**\n   * A human readable description of the action generated by server\n   */\n  desc: string;\n\n  /**\n   * model id of the action\n   */\n  id: string;\n\n  /**\n   * date created\n   */\n  dateCreated: string;\n};\n\ntype UnsavedAction = {\n  unsavedId: string;\n  /** Used to maintain order of unsaved actions */\n  unsavedDateCreated: string;\n  type: ActionType;\n\n  targetType: TargetType | null;\n\n  /**\n   * How to identify the target. Can be email, slack channel, pagerduty service,\n   * user_id, team_id, SentryApp id, etc\n   */\n  targetIdentifier: string | null;\n\n  /**\n   * The id of the integration, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  integrationId?: number | null;\n\n  /**\n   * The id of the SentryApp, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  sentryAppId?: number | null;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options: Array<{label: string; value: any}> | null;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n","import {User} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {IncidentRule} from 'app/views/alerts/incidentRules/types';\n\ntype Data = [number, {count: number}[]][];\n\nexport type Incident = {\n  dateClosed: string | null;\n  dateStarted: string;\n  dateDetected: string;\n  dateCreated: string;\n  id: string;\n  identifier: string;\n  isSubscribed: boolean;\n  groups: string[]; // Array of group ids\n  discoverQuery: string;\n  organizationId: string;\n  projects: string[]; // Array of slugs\n  seenBy: User[];\n  status: IncidentStatus;\n  statusMethod: IncidentStatusMethod;\n  title: string;\n  hasSeen: boolean;\n  alertRule: IncidentRule;\n  activities?: ActivityType[];\n};\n\nexport type IncidentStats = {\n  eventStats: {\n    data: Data;\n  };\n  totalEvents: number;\n  uniqueUsers: number;\n};\n\nexport type ActivityTypeDraft = {\n  comment: null | string;\n  dateCreated: string;\n  id: string;\n  incidentIdentifier: string;\n  type: IncidentActivityType;\n  user: User | null;\n};\n\nexport type ActivityType = ActivityTypeDraft & {\n  eventStats?: {data: Data};\n  previousValue: string | null;\n  value: string | null;\n};\n\nexport enum IncidentActivityType {\n  CREATED = 0,\n  DETECTED = 1,\n  STATUS_CHANGE = 2,\n  COMMENT = 3,\n  STARTED = 4,\n}\n\nexport enum IncidentStatus {\n  OPENED = 1,\n  CLOSED = 2,\n  WARNING = 10,\n  CRITICAL = 20,\n}\n\nexport enum IncidentStatusMethod {\n  MANUAL = 1,\n  RULE_UPDATED = 2,\n  RULE_TRIGGERED = 3,\n}\n\nexport enum AlertRuleStatus {\n  PENDING = 0,\n  SNAPSHOT = 4,\n  DISABLED = 5,\n}\n\nexport type CombinedMetricIssueAlerts = (IssueAlertRule | IncidentRule) & {\n  type: string;\n  latestIncident?: Incident | null;\n};\n","import {Client} from 'app/api';\nimport {t} from 'app/locale';\nimport {NewQuery, Project} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {getUtcDateString} from 'app/utils/dates';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {PRESET_AGGREGATES} from 'app/views/alerts/incidentRules/presets';\nimport {\n  Dataset,\n  Datasource,\n  EventTypes,\n  IncidentRule,\n  SavedIncidentRule,\n} from 'app/views/alerts/incidentRules/types';\n\nimport {Incident, IncidentStats, IncidentStatus} from '../types';\n\n// Use this api for requests that are getting cancelled\nconst uncancellableApi = new Client();\n\nexport function fetchAlertRule(orgId: string, ruleId: string): Promise<IncidentRule> {\n  return uncancellableApi.requestPromise(\n    `/organizations/${orgId}/alert-rules/${ruleId}/`\n  );\n}\n\nexport function fetchIncidentsForRule(\n  orgId: string,\n  alertRule: string,\n  start: string,\n  end: string\n): Promise<Incident[]> {\n  return uncancellableApi.requestPromise(`/organizations/${orgId}/incidents/`, {\n    query: {\n      alertRule,\n      includeSnapshots: true,\n      start,\n      end,\n      expand: ['activities', 'seen_by', 'original_alert_rule'],\n    },\n  });\n}\n\nexport function fetchIncident(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`);\n}\n\nexport function fetchIncidentStats(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<IncidentStats> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/stats/`);\n}\n\nexport function updateSubscription(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  isSubscribed?: boolean\n): Promise<Incident> {\n  const method = isSubscribed ? 'POST' : 'DELETE';\n  return api.requestPromise(\n    `/organizations/${orgId}/incidents/${alertId}/subscriptions/`,\n    {\n      method,\n    }\n  );\n}\n\nexport function updateStatus(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  status: IncidentStatus\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`, {\n    method: 'PUT',\n    data: {\n      status,\n    },\n  });\n}\n\n/**\n * Is incident open?\n *\n * @param {Object} incident Incident object\n * @returns {Boolean}\n */\nexport function isOpen(incident: Incident): boolean {\n  switch (incident.status) {\n    case IncidentStatus.CLOSED:\n      return false;\n    default:\n      return true;\n  }\n}\n\nexport function getIncidentMetricPreset(incident: Incident) {\n  const alertRule = incident?.alertRule;\n  const aggregate = alertRule?.aggregate ?? '';\n  const dataset = alertRule?.dataset ?? Dataset.ERRORS;\n\n  return PRESET_AGGREGATES.find(\n    p => p.validDataset.includes(dataset) && p.match.test(aggregate)\n  );\n}\n\n/**\n * Gets start and end date query parameters from stats\n */\nexport function getStartEndFromStats(stats: IncidentStats) {\n  const start = getUtcDateString(stats.eventStats.data[0][0] * 1000);\n  const end = getUtcDateString(\n    stats.eventStats.data[stats.eventStats.data.length - 1][0] * 1000\n  );\n\n  return {start, end};\n}\n\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n\nexport function isIssueAlert(\n  data: IssueAlertRule | SavedIncidentRule | IncidentRule\n): data is IssueAlertRule {\n  return !data.hasOwnProperty('triggers');\n}\n\nexport const DATA_SOURCE_LABELS = {\n  [Dataset.ERRORS]: t('Errors'),\n  [Dataset.TRANSACTIONS]: t('Transactions'),\n  [Datasource.ERROR_DEFAULT]: t('event.type:error OR event.type:default'),\n  [Datasource.ERROR]: t('event.type:error'),\n  [Datasource.DEFAULT]: t('event.type:default'),\n  [Datasource.TRANSACTION]: t('event.type:transaction'),\n};\n\n// Maps a datasource to the relevant dataset and event_types for the backend to use\nexport const DATA_SOURCE_TO_SET_AND_EVENT_TYPES = {\n  [Datasource.ERROR_DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR, EventTypes.DEFAULT],\n  },\n  [Datasource.ERROR]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n  },\n  [Datasource.DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.DEFAULT],\n  },\n  [Datasource.TRANSACTION]: {\n    dataset: Dataset.TRANSACTIONS,\n    eventTypes: [EventTypes.TRANSACTION],\n  },\n};\n\n// Converts the given dataset and event types array to a datasource for the datasource dropdown\nexport function convertDatasetEventTypesToSource(\n  dataset: Dataset,\n  eventTypes: EventTypes[]\n) {\n  // transactions only has one datasource option regardless of event type\n  if (dataset === Dataset.TRANSACTIONS) {\n    return Datasource.TRANSACTION;\n  }\n  // if no event type was provided use the default datasource\n  if (!eventTypes) {\n    return Datasource.ERROR;\n  }\n\n  if (eventTypes.includes(EventTypes.DEFAULT) && eventTypes.includes(EventTypes.ERROR)) {\n    return Datasource.ERROR_DEFAULT;\n  } else if (eventTypes.includes(EventTypes.DEFAULT)) {\n    return Datasource.DEFAULT;\n  } else {\n    return Datasource.ERROR;\n  }\n}\n\n/**\n * Attempt to guess the data source of a discover query\n *\n * @returns An object containing the datasource and new query without the datasource.\n * Returns null on no datasource.\n */\nexport function getQueryDatasource(\n  query: string\n): {source: Datasource; query: string} | null {\n  let match = query.match(\n    /\\(?\\bevent\\.type:(error|default|transaction)\\)?\\WOR\\W\\(?event\\.type:(error|default|transaction)\\)?/i\n  );\n  if (match) {\n    // should be [error, default] or [default, error]\n    const eventTypes = match.slice(1, 3).sort().join(',');\n    if (eventTypes !== 'default,error') {\n      return null;\n    }\n\n    return {source: Datasource.ERROR_DEFAULT, query: query.replace(match[0], '').trim()};\n  }\n\n  match = query.match(/(^|\\s)event\\.type:(error|default|transaction)/i);\n  if (match && Datasource[match[2].toUpperCase()]) {\n    return {\n      source: Datasource[match[2].toUpperCase()],\n      query: query.replace(match[0], '').trim(),\n    };\n  }\n\n  return null;\n}\n"],"sourceRoot":""}