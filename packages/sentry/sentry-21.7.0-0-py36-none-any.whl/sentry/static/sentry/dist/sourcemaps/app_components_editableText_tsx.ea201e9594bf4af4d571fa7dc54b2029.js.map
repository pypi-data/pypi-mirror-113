{"version":3,"sources":["webpack:///./app/utils/useKeyPress.tsx","webpack:///./app/components/editableText.tsx","webpack:///./app/utils/useOnClickOutside.tsx"],"names":["targetKey","useState","keyPressed","setKeyPressed","downHandler","key","upHandler","useEffect","window","addEventListener","removeEventListener","EditableText","ref","handler","value","onChange","name","errorMessage","successMessage","isDisabled","isEditing","setIsEditing","inputValue","setInputValue","isEmpty","trim","innerWrapperRef","useRef","labelRef","inputRef","enter","useKeypress","esc","revertValueAndCloseEditor","displayStatusMessage","listener","event","el","current","contains","target","document","onEnter","useCallback","onEsc","status","addSuccessMessage","addErrorMessage","inputElement","defined","focus","Wrapper","InputWrapper","StyledInput","InputLabel","Label","onClick","undefined","InnerLabel","space","TextOverflow","p","theme","gray200","gray100","borderRadius","Input"],"mappings":"ipBAmCA,EAhCA,SAAqBA,GAEnB,OAAoCC,eAAS,GAA7C,eAAOC,EAAP,KAAmBC,EAAnB,KAGA,SAASC,EAAT,GAA4B,EAANC,MACRL,GACVG,GAAc,GAKlB,SAASG,EAAT,GAA0B,EAAND,MACNL,GACVG,GAAc,GAelB,OAVAI,gBAAU,WAIR,OAHAC,OAAOC,iBAAiB,UAAWL,GACnCI,OAAOC,iBAAiB,QAASH,GAE1B,WACLE,OAAOE,oBAAoB,UAAWN,GACtCI,OAAOE,oBAAoB,QAASJ,MAErC,IAEIJ,G,gKCVT,SAASS,EAAT,GAOU,ICxBRC,EACAC,EDiBAC,EAMQ,EANRA,MACAC,EAKQ,EALRA,SACAC,EAIQ,EAJRA,KACAC,EAGQ,EAHRA,aACAC,EAEQ,EAFRA,eAEQ,IADRC,kBACQ,SACR,GAAkClB,eAAS,GAA3C,eAAOmB,EAAP,KAAkBC,EAAlB,KACA,GAAoCpB,cAASa,GAA7C,eAAOQ,EAAP,KAAmBC,EAAnB,KAEMC,GAAWF,EAAWG,OAEtBC,GAAkBC,YAAuB,MACzCC,GAAWD,YAAuB,MAClCE,GAAWF,YAAyB,MAEpCG,EAAQC,EAAY,SACpBC,EAAMD,EAAY,UAExB,SAASE,IACHnB,IAAUQ,GACZC,EAAcT,GAGZM,GACFC,GAAa,GC3CjBT,EDgDkBc,EC/ClBb,ED+CmC,WACjC,GAAIO,EAAW,CACb,GAAII,EAEF,YADAU,EAAqB,SAGnBZ,IAAeR,IACjBC,EAASO,GACTY,EAAqB,YAEvBb,GAAa,MCvDjBd,gBACE,WACE,IAAM4B,EAAW,SAACC,GAChB,IAAMC,EAAKzB,aAAH,EAAGA,EAAK0B,QAGXD,IAAMA,EAAGE,SAASH,EAAMI,SAI7B3B,EAAQuB,IAKV,OAFAK,SAAShC,iBAAiB,YAAa0B,GACvCM,SAAShC,iBAAiB,aAAc0B,GACjC,WACLM,SAAS/B,oBAAoB,YAAayB,GAC1CM,SAAS/B,oBAAoB,aAAcyB,MAI/C,CAACvB,EAAKC,IDsCR,IAAM6B,GAAUC,kBAAY,WAC1B,GAAIb,EAAO,CACT,GAAIN,EAEF,YADAU,EAAqB,SAInBZ,IAAeR,IACjBC,EAASO,GACTY,EAAqB,YAGvBb,GAAa,MAEd,CAACS,EAAOR,EAAYP,IAEjB6B,GAAQD,kBAAY,WACpBX,GACFC,MAED,CAACD,IAyBJ,SAASE,EAAqBW,GACb,UAAXA,EAOA3B,IACF4B,QAAkB5B,GAPdD,IACF8B,QAAgB9B,GAkBtB,OA5CAV,gBAAU,WACR0B,MACC,CAACd,EAAYL,KAGhBP,gBAAU,WACR,GAAIa,EAAW,CACb,IAAM4B,EAAenB,EAASS,SAC1BW,QAAQD,IACVA,EAAaE,WAGhB,CAAC9B,KAEJb,gBAAU,WACJa,IAEFsB,IAEAE,OAED,CAACF,EAASE,EAAOxB,KAwBlB,QAAC+B,EAAD,CAAShC,WAAYA,EAAYC,UAAWA,EAA5C,SACGA,GACC,QAACgC,EAAD,CACExC,IAAKc,EACLF,QAASA,EACT,eAAa,sBAHf,WAKE,QAAC6B,EAAD,CACErC,KAAMA,EACNJ,IAAKiB,EACLf,MAAOQ,EACPP,SApBV,SAA2BqB,GACzBb,EAAca,EAAMI,OAAO1B,WAqBrB,QAACwC,EAAD,UAAahC,QAGf,QAACiC,EAAD,CACEC,QAASrC,OAAasC,EAtB9B,WACEpC,GAAa,IAsBPT,IAAKgB,EACL,eAAa,sBAHf,WAKE,QAAC8B,EAAD,UAAapC,KACXH,IAAc,QAAC,IAAD,SAtIjBR,E,2BA6IT,QAEM4C,GAAQ,OAAO,MAAP,sBAAH,8DAIFI,OAAM,GAJJ,oBAQLD,GAAa,OAAOE,IAAP,sBAAH,8DAEc,SAAAC,GAAC,OAAIA,EAAEC,MAAMC,UAF3B,KAKVX,GAAe,OAAO,MAAP,sBAAH,oCAEF,SAAAS,GAAC,OAAIA,EAAEC,MAAME,UAFX,mBAGC,SAAAH,GAAC,OAAIA,EAAEC,MAAMG,eAHd,aAILN,OAAM,IAJD,MAIUA,OAAM,GAJhB,2BAKSA,OAAM,GALf,MAQZN,GAAc,OAAOa,IAAP,sBAAH,qFAKJP,OAAM,IALF,KAKUA,OAAM,GALhB,iDAcXL,GAAa,OAAO,MAAP,sBAAH,iDAIDK,OAAM,GAJL,KAOVR,GAAU,OAAO,MAAP,sBAAH,iBAGT,SAAAU,GAAC,OACDA,EAAE1C,YAAF,kBAEIuC,EAFJ,kEAJS","file":"chunks/app_components_editableText_tsx.xxxxxxxxxxxxxxxxxxxx.js","sourcesContent":["// hook from https://usehooks.com/useKeyPress/\nimport {useEffect, useState} from 'react';\n\nfunction useKeyPress(targetKey: React.KeyboardEvent['key']) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // If pressed key is the target key then set to true\n  function downHandler({key}) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  // If released key is the target key then set to false\n  function upHandler({key}) {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  }\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n\nexport default useKeyPress;\n","import {useCallback, useEffect, useRef, useState} from 'react';\nimport * as React from 'react';\nimport styled from '@emotion/styled';\n\nimport {addErrorMessage, addSuccessMessage} from 'app/actionCreators/indicator';\nimport TextOverflow from 'app/components/textOverflow';\nimport {IconEdit} from 'app/icons/iconEdit';\nimport space from 'app/styles/space';\nimport {defined} from 'app/utils';\nimport useKeypress from 'app/utils/useKeyPress';\nimport useOnClickOutside from 'app/utils/useOnClickOutside';\nimport Input from 'app/views/settings/components/forms/controls/input';\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n  name?: string;\n  errorMessage?: React.ReactNode;\n  successMessage?: React.ReactNode;\n  isDisabled?: boolean;\n};\n\nfunction EditableText({\n  value,\n  onChange,\n  name,\n  errorMessage,\n  successMessage,\n  isDisabled = false,\n}: Props) {\n  const [isEditing, setIsEditing] = useState(false);\n  const [inputValue, setInputValue] = useState(value);\n\n  const isEmpty = !inputValue.trim();\n\n  const innerWrapperRef = useRef<HTMLDivElement>(null);\n  const labelRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const enter = useKeypress('Enter');\n  const esc = useKeypress('Escape');\n\n  function revertValueAndCloseEditor() {\n    if (value !== inputValue) {\n      setInputValue(value);\n    }\n\n    if (isEditing) {\n      setIsEditing(false);\n    }\n  }\n\n  // check to see if the user clicked outside of this component\n  useOnClickOutside(innerWrapperRef, () => {\n    if (isEditing) {\n      if (isEmpty) {\n        displayStatusMessage('error');\n        return;\n      }\n      if (inputValue !== value) {\n        onChange(inputValue);\n        displayStatusMessage('success');\n      }\n      setIsEditing(false);\n    }\n  });\n\n  const onEnter = useCallback(() => {\n    if (enter) {\n      if (isEmpty) {\n        displayStatusMessage('error');\n        return;\n      }\n\n      if (inputValue !== value) {\n        onChange(inputValue);\n        displayStatusMessage('success');\n      }\n\n      setIsEditing(false);\n    }\n  }, [enter, inputValue, onChange]);\n\n  const onEsc = useCallback(() => {\n    if (esc) {\n      revertValueAndCloseEditor();\n    }\n  }, [esc]);\n\n  useEffect(() => {\n    revertValueAndCloseEditor();\n  }, [isDisabled, value]);\n\n  // focus the cursor in the input field on edit start\n  useEffect(() => {\n    if (isEditing) {\n      const inputElement = inputRef.current;\n      if (defined(inputElement)) {\n        inputElement.focus();\n      }\n    }\n  }, [isEditing]);\n\n  useEffect(() => {\n    if (isEditing) {\n      // if Enter is pressed, save the value and close the editor\n      onEnter();\n      // if Escape is pressed, revert the value and close the editor\n      onEsc();\n    }\n  }, [onEnter, onEsc, isEditing]); // watch the Enter and Escape key presses\n\n  function displayStatusMessage(status: 'error' | 'success') {\n    if (status === 'error') {\n      if (errorMessage) {\n        addErrorMessage(errorMessage);\n      }\n      return;\n    }\n\n    if (successMessage) {\n      addSuccessMessage(successMessage);\n    }\n  }\n\n  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {\n    setInputValue(event.target.value);\n  }\n\n  function handleEditClick() {\n    setIsEditing(true);\n  }\n\n  return (\n    <Wrapper isDisabled={isDisabled} isEditing={isEditing}>\n      {isEditing ? (\n        <InputWrapper\n          ref={innerWrapperRef}\n          isEmpty={isEmpty}\n          data-test-id=\"editable-text-input\"\n        >\n          <StyledInput\n            name={name}\n            ref={inputRef}\n            value={inputValue}\n            onChange={handleInputChange}\n          />\n          <InputLabel>{inputValue}</InputLabel>\n        </InputWrapper>\n      ) : (\n        <Label\n          onClick={isDisabled ? undefined : handleEditClick}\n          ref={labelRef}\n          data-test-id=\"editable-text-label\"\n        >\n          <InnerLabel>{inputValue}</InnerLabel>\n          {!isDisabled && <IconEdit />}\n        </Label>\n      )}\n    </Wrapper>\n  );\n}\n\nexport default EditableText;\n\nconst Label = styled('div')`\n  display: grid;\n  grid-auto-flow: column;\n  align-items: center;\n  gap: ${space(1)};\n  cursor: pointer;\n`;\n\nconst InnerLabel = styled(TextOverflow)`\n  border-top: 1px solid transparent;\n  border-bottom: 1px dotted ${p => p.theme.gray200};\n`;\n\nconst InputWrapper = styled('div')<{isEmpty: boolean}>`\n  display: inline-block;\n  background: ${p => p.theme.gray100};\n  border-radius: ${p => p.theme.borderRadius};\n  margin: -${space(0.5)} -${space(1)};\n  max-width: calc(100% + ${space(2)});\n`;\n\nconst StyledInput = styled(Input)`\n  border: none !important;\n  background: transparent;\n  height: auto;\n  min-height: 34px;\n  padding: ${space(0.5)} ${space(1)};\n  &,\n  &:focus,\n  &:active,\n  &:hover {\n    box-shadow: none;\n  }\n`;\n\nconst InputLabel = styled('div')`\n  height: 0;\n  opacity: 0;\n  white-space: pre;\n  padding: 0 ${space(1)};\n`;\n\nconst Wrapper = styled('div')<{isDisabled: boolean; isEditing: boolean}>`\n  display: flex;\n\n  ${p =>\n    p.isDisabled &&\n    `\n      ${InnerLabel} {\n        border-bottom-color: transparent;\n      }\n    `}\n`;\n","// hook from https://usehooks.com/useOnClickOutside/\nimport {useEffect} from 'react';\nimport * as React from 'react';\n\nfunction useOnClickOutside<T extends HTMLElement = HTMLElement>(\n  ref: React.RefObject<T>,\n  handler: (event: MouseEvent | TouchEvent) => void\n) {\n  useEffect(\n    () => {\n      const listener = (event: MouseEvent | TouchEvent) => {\n        const el = ref?.current;\n\n        // Do nothing if clicking ref's element or descendent elements\n        if (!el || el.contains(event.target as Node)) {\n          return;\n        }\n\n        handler(event);\n      };\n\n      document.addEventListener('mousedown', listener);\n      document.addEventListener('touchstart', listener);\n      return () => {\n        document.removeEventListener('mousedown', listener);\n        document.removeEventListener('touchstart', listener);\n      };\n    },\n    // Reload only if ref or handler changes\n    [ref, handler]\n  );\n}\n\nexport default useOnClickOutside;\n"],"sourceRoot":""}