{"version":3,"sources":["webpack:///./app/components/charts/areaChart.tsx","webpack:///./app/components/charts/series/areaSeries.tsx","webpack:///./app/components/charts/chartZoom.tsx","webpack:///./app/components/charts/transparentLoadingMask.tsx","webpack:///./app/utils/discover/charts.tsx"],"names":["AreaChart","this","props","series","stacked","colors","map","i","seriesName","data","otherSeriesProps","LineSeries","AreaSeries","stack","undefined","name","value","lineStyle","color","opacity","width","areaStyle","animation","animationThreshold","animationDuration","React","getDate","date","moment","format","ChartZoom","currentPeriod","period","start","end","saveHistory","router","onZoom","usePageDate","startFormatted","endFormatted","history","push","callIfFunction","zooming","newQuery","location","query","pageStart","getUtcDateString","pageEnd","pageStatsPeriod","qs","pathname","updateDateTime","getUtcToLocalDateObject","saveCurrentPeriod","chart","dispatchAction","type","key","dataZoomSelectActive","onChartReady","evt","length","setPeriod","onRestore","axis","getModel","option","xAxis","rangeStart","rangeEnd","previousPeriod","pop","onDataZoom","onFinished","disabled","_utc","utc","_start","_end","children","xAxisIndex","isGroupedByDate","handleChartReady","dataZoom","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","zoom","back","iconStyle","borderWidth","handleDataZoom","handleChartFinished","handleZoomRestore","TransparentLoadingMask","className","visible","other","p","tooltipFormatter","aggregateOutputType","toLocaleString","formatPercentage","getDuration","toString","axisLabelFormatter","abbreviation","formatAbbreviatedNumber","axisDuration","WEEK","label","toFixed","t","DAY","HOUR","MINUTE","SECOND"],"mappings":"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","file":"chunks/app_components_charts_areaChart_tsx-app_components_charts_chartZoom_tsx-app_components_charts-440cde.xxxxxxxxxxxxxxxxxxxx.js","sourcesContent":["import * as React from 'react';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport AreaSeries from './series/areaSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type AreaChartSeries = Series & Omit<EChartOption.SeriesLine, 'data' | 'name'>;\n\ntype Props = Omit<ChartProps, 'series'> & {\n  stacked?: boolean;\n  series: AreaChartSeries[];\n};\n\nclass AreaChart extends React.Component<Props> {\n  render() {\n    const {series, stacked, colors, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        colors={colors}\n        series={series.map(({seriesName, data, ...otherSeriesProps}, i) =>\n          AreaSeries({\n            stack: stacked ? 'area' : undefined,\n            name: seriesName,\n            data: data.map(({name, value}) => [name, value]),\n            lineStyle: {\n              color: colors?.[i],\n              opacity: 1,\n              width: 0.4,\n            },\n            areaStyle: {\n              color: colors?.[i],\n              opacity: 1.0,\n            },\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n            ...otherSeriesProps,\n          })\n        )}\n      />\n    );\n  }\n}\n\nexport default AreaChart;\n","import {EChartOption} from 'echarts';\n\nimport LineSeries from 'app/components/charts/series/lineSeries';\n\nexport default function AreaSeries(\n  props: EChartOption.SeriesLine = {}\n): EChartOption.SeriesLine {\n  return LineSeries({\n    ...props,\n  });\n}\n","import * as React from 'react';\nimport {WithRouterProps} from 'react-router/lib/withRouter';\nimport {EChartOption} from 'echarts/lib/echarts';\nimport moment from 'moment';\nimport * as qs from 'query-string';\n\nimport {updateDateTime} from 'app/actionCreators/globalSelection';\nimport DataZoomInside from 'app/components/charts/components/dataZoomInside';\nimport ToolBox from 'app/components/charts/components/toolBox';\nimport {DateString} from 'app/types';\nimport {\n  EChartChartReadyHandler,\n  EChartDataZoomHandler,\n  EChartFinishedHandler,\n  EChartRestoreHandler,\n} from 'app/types/echarts';\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport {getUtcDateString, getUtcToLocalDateObject} from 'app/utils/dates';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\ntype Period = {\n  period: string;\n  start: DateString;\n  end: DateString;\n};\n\nconst ZoomPropKeys = [\n  'period',\n  'xAxis',\n  'onChartReady',\n  'onDataZoom',\n  'onRestore',\n  'onFinished',\n] as const;\n\nexport type ZoomRenderProps = Pick<Props, typeof ZoomPropKeys[number]> & {\n  utc?: boolean;\n  start?: Date;\n  end?: Date;\n  isGroupedByDate?: boolean;\n  showTimeInTooltip?: boolean;\n  dataZoom?: EChartOption.DataZoom[];\n  toolBox?: EChartOption['toolbox'];\n};\n\ntype Props = {\n  router?: WithRouterProps['router'];\n  children: (props: ZoomRenderProps) => React.ReactNode;\n  disabled?: boolean;\n  xAxis?: EChartOption.XAxis;\n  xAxisIndex?: number | number[];\n  start?: DateString;\n  end?: DateString;\n  period?: string;\n  utc?: boolean | null;\n  onChartReady?: EChartChartReadyHandler;\n  onDataZoom?: EChartDataZoomHandler;\n  onFinished?: EChartFinishedHandler;\n  onRestore?: EChartRestoreHandler;\n  onZoom?: (period: Period) => void;\n  usePageDate?: boolean;\n};\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends React.Component<Props> {\n  constructor(props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  history: Period[];\n  currentPeriod?: Period;\n  zooming: (() => void) | null = null;\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory = false) => {\n    const {router, onZoom, usePageDate} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod!);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    callIfFunction(onZoom, {\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      if (usePageDate && router) {\n        const newQuery = {\n          ...router.location.query,\n          pageStart: start ? getUtcDateString(start) : undefined,\n          pageEnd: end ? getUtcDateString(end) : undefined,\n          pageStatsPeriod: period ?? undefined,\n        };\n\n        // Only push new location if query params has changed because this will cause a heavy re-render\n        if (qs.stringify(newQuery) !== qs.stringify(router.location.query)) {\n          router.push({\n            pathname: router.location.pathname,\n            query: newQuery,\n          });\n        }\n      } else {\n        updateDateTime(\n          {\n            period,\n            start: startFormatted\n              ? getUtcToLocalDateObject(startFormatted)\n              : startFormatted,\n            end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n          },\n          router\n        );\n      }\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    chart.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: true,\n    });\n\n    callIfFunction(this.props.onChartReady, chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    callIfFunction(this.props.onRestore, evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {xAxis} = model.option;\n    const axis = xAxis[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (axis.rangeStart === null && axis.rangeEnd === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(axis.rangeStart);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(axis.rangeEnd);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    callIfFunction(this.props.onDataZoom, evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = () => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc: _utc,\n      start: _start,\n      end: _end,\n      disabled,\n      children,\n      xAxisIndex,\n\n      router: _router,\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      ...props\n    } = this.props;\n\n    const utc = _utc ?? undefined;\n    const start = _start ? getUtcToLocalDateObject(_start) : undefined;\n    const end = _end ? getUtcToLocalDateObject(_end) : undefined;\n\n    if (disabled) {\n      return children({\n        utc,\n        start,\n        end,\n        ...props,\n      });\n    }\n\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      start,\n      end,\n      dataZoom: DataZoomInside({xAxisIndex}),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onFinished: this.handleChartFinished,\n      onRestore: this.handleZoomRestore,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nimport LoadingMask from 'app/components/loadingMask';\n\ntype Props = {\n  visible: boolean;\n  className?: string;\n  children?: React.ReactNode;\n} & React.ComponentProps<typeof LoadingMask>;\n\nconst TransparentLoadingMask = styled(\n  ({className, visible, children, ...props}: Props) => {\n    const other = visible ? {...props, 'data-test-id': 'loading-placeholder'} : props;\n    return (\n      <LoadingMask className={className} {...other}>\n        {children}\n      </LoadingMask>\n    );\n  }\n)<Props>`\n  ${p => !p.visible && 'display: none;'};\n  opacity: 0.4;\n  z-index: 1;\n`;\n\nexport default TransparentLoadingMask;\n","import {t} from 'app/locale';\nimport {aggregateOutputType} from 'app/utils/discover/fields';\nimport {\n  DAY,\n  formatAbbreviatedNumber,\n  formatPercentage,\n  getDuration,\n  HOUR,\n  MINUTE,\n  SECOND,\n  WEEK,\n} from 'app/utils/formatters';\n\n/**\n * Formatter for chart tooltips that handle a variety of discover result values\n */\nexport function tooltipFormatter(value: number, seriesName: string = ''): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 2);\n    case 'duration':\n      return getDuration(value / 1000, 2, true);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Formatter for chart axis labels that handle a variety of discover result values\n * This function is *very similar* to tooltipFormatter but outputs data with less precision.\n */\nexport function axisLabelFormatter(\n  value: number,\n  seriesName: string,\n  abbreviation: boolean = false\n): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return abbreviation ? formatAbbreviatedNumber(value) : value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 0);\n    case 'duration':\n      return axisDuration(value);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Specialized duration formatting for axis labels.\n * In that context we are ok sacrificing accuracy for more\n * consistent sizing.\n *\n * @param value Number of milliseconds to format.\n */\nexport function axisDuration(value: number): string {\n  if (value === 0) {\n    return '0';\n  }\n  if (value >= WEEK) {\n    const label = (value / WEEK).toFixed(0);\n    return t('%swk', label);\n  }\n  if (value >= DAY) {\n    const label = (value / DAY).toFixed(0);\n    return t('%sd', label);\n  }\n  if (value >= HOUR) {\n    const label = (value / HOUR).toFixed(0);\n    return t('%shr', label);\n  }\n  if (value >= MINUTE) {\n    const label = (value / MINUTE).toFixed(0);\n    return t('%smin', label);\n  }\n  if (value >= SECOND) {\n    const label = (value / SECOND).toFixed(0);\n    return t('%ss', label);\n  }\n  const label = value.toFixed(0);\n  return t('%sms', label);\n}\n"],"sourceRoot":""}