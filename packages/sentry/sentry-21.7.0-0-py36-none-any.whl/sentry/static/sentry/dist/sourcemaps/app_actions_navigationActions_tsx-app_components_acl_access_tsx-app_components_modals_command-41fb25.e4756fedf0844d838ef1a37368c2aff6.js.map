{"version":3,"sources":["webpack:///./app/actions/navigationActions.tsx","webpack:///./app/actions/projectActions.tsx","webpack:///./app/actions/teamActions.tsx","webpack:///./app/components/acl/access.tsx","webpack:///./app/components/modals/commandPalette.tsx","webpack:///./app/stores/projectsStore.tsx","webpack:///./app/utils/parseLinkHeader.tsx","webpack:///./app/utils/withApi.tsx","webpack:///./app/utils/withProjects.tsx","webpack:///../node_modules/lodash/flattenDepth.js"],"names":["Reflux","TeamActions","DEFAULT_NO_ACCESS_MESSAGE","type","icon","size","t","Access","this","props","organization","config","access","requireAll","isSuperuser","renderNoAccessMessage","children","orgAccess","hasAccess","acc","includes","hasSuperuser","user","renderProps","render","isRenderFunc","React","withOrganization","withConfig","CommandPalette","analytics","theme","Body","injectedCss","css","entryPoint","minSearch","maxResults","dropdownStyle","border","renderInput","getInputProps","InputWrapper","StyledInput","autoFocus","placeholder","Component","withTheme","modalCss","space","Input","storeConfig","itemsById","loading","init","reset","listenTo","ProjectActions","onAddTeam","onChangeSlug","onCreateSuccess","loadInitialData","onStatsLoadSuccess","onRemoveTeam","onUpdateSuccess","onDeleteTeam","items","reduce","map","project","id","trigger","Set","Object","keys","prevSlug","newSlug","prevProject","getBySlug","newProject","slug","data","getById","assign","touchedIds","entries","forEach","projectId","stats","push","teamSlug","projectIds","getWithTeam","projectWithTeam","removeTeamFromProject","projectSlug","team","teams","newTeams","filter","getAll","find","values","sort","a","b","getBySlugs","slugs","getState","projects","ProjectsStore","parseLinkHeader","header","header_vals","split","links","val","match","exec","hasResults","href","results","cursor","WrappedComponent","persistInFlight","api","Client","clear","getDisplayName","WithProjects","setState","undefined","unsubscribe","state","loadingProjects","baseFlatten","toInteger","module","exports","array","depth","length"],"mappings":"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","file":"chunks/app_actions_navigationActions_tsx-app_components_acl_access_tsx-app_components_modals_command-41fb25.xxxxxxxxxxxxxxxxxxxx.js","sourcesContent":["import Reflux from 'reflux';\n\nexport default Reflux.createActions(['setLastRoute']);\n","import Reflux from 'reflux';\n\nexport default Reflux.createActions([\n  'addTeam',\n  'addTeamError',\n  'addTeamSuccess',\n  'changeSlug',\n  'createSuccess',\n  'loadProjects',\n  'loadStats',\n  'loadStatsError',\n  'loadStatsForProjectSuccess',\n  'loadStatsSuccess',\n  'removeProject',\n  'removeProjectError',\n  'removeProjectSuccess',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'reset',\n  'setActive',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n","import Reflux from 'reflux';\n\nconst TeamActions = Reflux.createActions([\n  'createTeam',\n  'createTeamError',\n  'createTeamSuccess',\n  'fetchAll',\n  'fetchAllError',\n  'fetchAllSuccess',\n  'fetchDetails',\n  'fetchDetailsError',\n  'fetchDetailsSuccess',\n  'loadTeams',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n\nexport default TeamActions;\n","import * as React from 'react';\n\nimport Alert from 'app/components/alert';\nimport {IconInfo} from 'app/icons';\nimport {t} from 'app/locale';\nimport {Config, Organization, Scope} from 'app/types';\nimport {isRenderFunc} from 'app/utils/isRenderFunc';\nimport withConfig from 'app/utils/withConfig';\nimport withOrganization from 'app/utils/withOrganization';\n\nconst DEFAULT_NO_ACCESS_MESSAGE = (\n  <Alert type=\"error\" icon={<IconInfo size=\"md\" />}>\n    {t('You do not have sufficient permissions to access this.')}\n  </Alert>\n);\n\n// Props that function children will get.\nexport type ChildRenderProps = {\n  hasAccess: boolean;\n  hasSuperuser: boolean;\n};\n\ntype ChildFunction = (props: ChildRenderProps) => React.ReactNode;\n\ntype DefaultProps = {\n  /**\n   * Should the component require all access levels or just one or more.\n   */\n  requireAll?: boolean;\n\n  /**\n   * Requires superuser\n   */\n  isSuperuser?: boolean;\n\n  /**\n   * Custom renderer function for \"no access\" message OR `true` to use\n   * default message. `false` will suppress message.\n   */\n  renderNoAccessMessage: ChildFunction | boolean;\n\n  /**\n   * List of required access levels\n   */\n  access: Scope[];\n};\n\nconst defaultProps: DefaultProps = {\n  renderNoAccessMessage: false,\n  isSuperuser: false,\n  requireAll: true,\n  access: [],\n};\n\ntype Props = {\n  /**\n   * Current Organization\n   */\n  organization: Organization;\n\n  /**\n   * Configuration from ConfigStore\n   */\n  config: Config;\n\n  /**\n   * Children can be a node or a function as child.\n   */\n  children?: React.ReactNode | ChildFunction;\n} & Partial<DefaultProps>;\n\n/**\n * Component to handle access restrictions.\n */\nclass Access extends React.Component<Props> {\n  static defaultProps = defaultProps;\n\n  render() {\n    const {\n      organization,\n      config,\n      access,\n      requireAll,\n      isSuperuser,\n      renderNoAccessMessage,\n      children,\n    } = this.props;\n\n    const {access: orgAccess} = organization || {access: []};\n    const method = requireAll ? 'every' : 'some';\n\n    const hasAccess = !access || access[method](acc => orgAccess.includes(acc));\n    const hasSuperuser = !!(config.user && config.user.isSuperuser);\n\n    const renderProps: ChildRenderProps = {\n      hasAccess,\n      hasSuperuser,\n    };\n\n    const render = hasAccess && (!isSuperuser || hasSuperuser);\n\n    if (!render && typeof renderNoAccessMessage === 'function') {\n      return renderNoAccessMessage(renderProps);\n    } else if (!render && renderNoAccessMessage) {\n      return DEFAULT_NO_ACCESS_MESSAGE;\n    }\n\n    if (isRenderFunc<ChildFunction>(children)) {\n      return children(renderProps);\n    }\n\n    return render ? children : null;\n  }\n}\n\nexport default withOrganization(withConfig(Access));\n","import {Component} from 'react';\nimport {ClassNames, css, withTheme} from '@emotion/react';\nimport styled from '@emotion/styled';\n\nimport {ModalRenderProps} from 'app/actionCreators/modal';\nimport Search from 'app/components/search';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {analytics} from 'app/utils/analytics';\nimport {Theme} from 'app/utils/theme';\nimport Input from 'app/views/settings/components/forms/controls/input';\n\ntype Props = ModalRenderProps & {\n  theme: Theme;\n};\n\nclass CommandPalette extends Component<Props> {\n  componentDidMount() {\n    analytics('omnisearch.open', {});\n  }\n\n  render() {\n    const {theme, Body} = this.props;\n\n    return (\n      <Body>\n        <ClassNames>\n          {({css: injectedCss}) => (\n            <Search\n              entryPoint=\"command_palette\"\n              minSearch={1}\n              maxResults={10}\n              dropdownStyle={injectedCss`\n                width: 100%;\n                border: transparent;\n                border-top-left-radius: 0;\n                border-top-right-radius: 0;\n                position: initial;\n                box-shadow: none;\n                border-top: 1px solid ${theme.border};\n              `}\n              renderInput={({getInputProps}) => (\n                <InputWrapper>\n                  <StyledInput\n                    autoFocus\n                    {...getInputProps({\n                      type: 'text',\n                      placeholder: t('Search for projects, teams, settings, etc...'),\n                    })}\n                  />\n                </InputWrapper>\n              )}\n            />\n          )}\n        </ClassNames>\n      </Body>\n    );\n  }\n}\n\nexport default withTheme(CommandPalette);\n\nexport const modalCss = css`\n  [role='document'] {\n    padding: 0;\n  }\n`;\n\nconst InputWrapper = styled('div')`\n  padding: ${space(0.25)};\n`;\n\nconst StyledInput = styled(Input)`\n  width: 100%;\n  padding: ${space(1)};\n  border-radius: 8px;\n\n  outline: none;\n  border: none;\n  box-shadow: none;\n\n  :focus,\n  :active,\n  :hover {\n    outline: none;\n    border: none;\n    box-shadow: none;\n  }\n`;\n","import Reflux from 'reflux';\n\nimport ProjectActions from 'app/actions/projectActions';\nimport TeamActions from 'app/actions/teamActions';\nimport {Project, Team} from 'app/types';\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\ntype StatsData = Record<string, Project['stats']>;\n\n/**\n * Attributes that need typing but aren't part of the external interface,\n */\ntype Internals = {\n  itemsById: Record<string, Project>;\n  loading: boolean;\n};\n\ntype ProjectsStoreInterface = {\n  init: () => void;\n  reset: () => void;\n  loadInitialData: (projects: Project[]) => void;\n  onStatsLoadSuccess: (data: StatsData) => void;\n  onChangeSlug: (prevSlug: string, newSlug: string) => void;\n  onCreateSuccess: (project: Project) => void;\n  onUpdateSuccess: (data: Partial<Project>) => void;\n  onDeleteTeam: (slug: string) => void;\n  onRemoveTeam: (teamSlug: string, projectSlug: string) => void;\n  onAddTeam: (team: Team, projectSlug: string) => void;\n  removeTeamFromProject: (teamSlug: string, project: Project) => void;\n  getWithTeam: (teamSlug: string) => Project[];\n  getAll: () => Project[];\n  getBySlugs: (slug: string[]) => Project[];\n  getState: (slugs?: string[]) => State;\n  getById: (id?: string) => Project | undefined;\n  getBySlug: (slug?: string) => Project | undefined;\n};\n\nconst storeConfig: Reflux.StoreDefinition & Internals & ProjectsStoreInterface = {\n  itemsById: {},\n  loading: true,\n\n  init() {\n    this.reset();\n\n    this.listenTo(ProjectActions.addTeamSuccess, this.onAddTeam);\n    this.listenTo(ProjectActions.changeSlug, this.onChangeSlug);\n    this.listenTo(ProjectActions.createSuccess, this.onCreateSuccess);\n    this.listenTo(ProjectActions.loadProjects, this.loadInitialData);\n    this.listenTo(ProjectActions.loadStatsSuccess, this.onStatsLoadSuccess);\n    this.listenTo(ProjectActions.removeTeamSuccess, this.onRemoveTeam);\n    this.listenTo(ProjectActions.reset, this.reset);\n    this.listenTo(ProjectActions.updateSuccess, this.onUpdateSuccess);\n\n    this.listenTo(TeamActions.removeTeamSuccess, this.onDeleteTeam);\n  },\n\n  reset() {\n    this.itemsById = {};\n    this.loading = true;\n  },\n\n  loadInitialData(items: Project[]) {\n    this.itemsById = items.reduce((map, project) => {\n      map[project.id] = project;\n      return map;\n    }, {});\n    this.loading = false;\n    this.trigger(new Set(Object.keys(this.itemsById)));\n  },\n\n  onChangeSlug(prevSlug: string, newSlug: string) {\n    const prevProject = this.getBySlug(prevSlug);\n\n    // This shouldn't happen\n    if (!prevProject) {\n      return;\n    }\n\n    const newProject = {\n      ...prevProject,\n      slug: newSlug,\n    };\n\n    this.itemsById = {\n      ...this.itemsById,\n      [newProject.id]: newProject,\n    };\n\n    // Ideally we'd always trigger this.itemsById, but following existing patterns\n    // so we don't break things\n    this.trigger(new Set([prevProject.id]));\n  },\n\n  onCreateSuccess(project: Project) {\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: project,\n    };\n    this.trigger(new Set([project.id]));\n  },\n\n  onUpdateSuccess(data: Partial<Project>) {\n    const project = this.getById(data.id);\n    if (!project) {\n      return;\n    }\n    const newProject = Object.assign({}, project, data);\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: newProject,\n    };\n    this.trigger(new Set([data.id]));\n  },\n\n  onStatsLoadSuccess(data) {\n    const touchedIds: string[] = [];\n    Object.entries(data || {}).forEach(([projectId, stats]) => {\n      if (projectId in this.itemsById) {\n        this.itemsById[projectId].stats = stats;\n        touchedIds.push(projectId);\n      }\n    });\n    this.trigger(new Set(touchedIds));\n  },\n\n  /**\n   * Listener for when a team is completely removed\n   *\n   * @param teamSlug Team Slug\n   */\n  onDeleteTeam(teamSlug: string) {\n    // Look for team in all projects\n    const projectIds = this.getWithTeam(teamSlug).map(projectWithTeam => {\n      this.removeTeamFromProject(teamSlug, projectWithTeam);\n      return projectWithTeam.id;\n    });\n\n    this.trigger(new Set([projectIds]));\n  },\n\n  onRemoveTeam(teamSlug: string, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n    if (!project) {\n      return;\n    }\n\n    this.removeTeamFromProject(teamSlug, project);\n    this.trigger(new Set([project.id]));\n  },\n\n  onAddTeam(team: Team, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n\n    // Don't do anything if we can't find a project\n    if (!project) {\n      return;\n    }\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: [...project.teams, team],\n      },\n    };\n\n    this.trigger(new Set([project.id]));\n  },\n\n  // Internal method, does not trigger\n  removeTeamFromProject(teamSlug: string, project: Project) {\n    const newTeams = project.teams.filter(({slug}) => slug !== teamSlug);\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: newTeams,\n      },\n    };\n  },\n\n  /**\n   * Returns a list of projects that has the specified team\n   *\n   * @param {String} teamSlug Slug of team to find in projects\n   */\n  getWithTeam(teamSlug: string) {\n    return this.getAll().filter(({teams}) => teams.find(({slug}) => slug === teamSlug));\n  },\n\n  getAll() {\n    return Object.values(this.itemsById).sort((a: Project, b: Project) => {\n      if (a.slug > b.slug) {\n        return 1;\n      }\n      if (a.slug < b.slug) {\n        return -1;\n      }\n      return 0;\n    });\n  },\n\n  getById(id) {\n    return this.getAll().find(project => project.id === id);\n  },\n\n  getBySlug(slug) {\n    return this.getAll().find(project => project.slug === slug);\n  },\n\n  getBySlugs(slugs: string[]) {\n    return this.getAll().filter(project => slugs.includes(project.slug));\n  },\n\n  getState(slugs?: string[]): State {\n    return {\n      projects: slugs ? this.getBySlugs(slugs) : this.getAll(),\n      loading: this.loading,\n    };\n  },\n};\n\ntype ProjectsStore = Reflux.Store & ProjectsStoreInterface;\n\nconst ProjectsStore = Reflux.createStore(storeConfig) as ProjectsStore;\n\nexport default ProjectsStore;\n","export default function parseLinkHeader(header: string | null): {\n  [key: string]: {href: string; results: boolean | null; cursor: string};\n} {\n  if (header === null || header === '') {\n    return {};\n  }\n\n  const header_vals = header.split(',');\n  const links = {};\n\n  header_vals.forEach(val => {\n    const match =\n      /<([^>]+)>; rel=\"([^\"]+)\"(?:; results=\"([^\"]+)\")?(?:; cursor=\"([^\"]+)\")?/g.exec(\n        val\n      );\n    const hasResults = match![3] === 'true' ? true : match![3] === 'false' ? false : null;\n\n    links[match![2]] = {\n      href: match![1],\n      results: hasResults,\n      cursor: match![4],\n    };\n  });\n\n  return links;\n}\n","import * as React from 'react';\n\nimport {Client} from 'app/api';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedApiProps = {\n  api: Client;\n};\n\ntype WrappedProps<P> = Omit<P, keyof InjectedApiProps> & Partial<InjectedApiProps>;\n\ntype OptionProps = {\n  /**\n   * Enabling this option will disable clearing in-flight requests when the\n   * component is unmounted.\n   *\n   * This may be useful in situations where your component needs to finish up\n   * some where the client was passed into some type of action creator and the\n   * component is unmounted.\n   */\n  persistInFlight?: boolean;\n};\n\n/**\n * React Higher-Order Component (HoC) that provides \"api\" client when mounted,\n * and clears API requests when component is unmounted.\n */\nconst withApi = <P extends InjectedApiProps>(\n  WrappedComponent: React.ComponentType<P>,\n  {persistInFlight}: OptionProps = {}\n) =>\n  class extends React.Component<WrappedProps<P>> {\n    static displayName = `withApi(${getDisplayName(WrappedComponent)})`;\n\n    constructor(props: WrappedProps<P>) {\n      super(props);\n      this.api = new Client();\n    }\n\n    componentWillUnmount() {\n      if (!persistInFlight) {\n        this.api.clear();\n      }\n    }\n\n    private api: Client;\n\n    render() {\n      const {api, ...props} = this.props;\n      return <WrappedComponent {...({api: api ?? this.api, ...props} as P)} />;\n    }\n  };\n\nexport default withApi;\n","import * as React from 'react';\n\nimport ProjectsStore from 'app/stores/projectsStore';\nimport {Project} from 'app/types';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedProjectsProps = {\n  projects: Project[];\n  loadingProjects?: boolean;\n};\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\n/**\n * Higher order component that uses ProjectsStore and provides a list of projects\n */\nfunction withProjects<P extends InjectedProjectsProps>(\n  WrappedComponent: React.ComponentType<P>\n) {\n  class WithProjects extends React.Component<\n    Omit<P, keyof InjectedProjectsProps> & Partial<InjectedProjectsProps>,\n    State\n  > {\n    static displayName = `withProjects(${getDisplayName(WrappedComponent)})`;\n\n    state: State = ProjectsStore.getState();\n\n    componentWillUnmount() {\n      this.unsubscribe();\n    }\n\n    unsubscribe = ProjectsStore.listen(\n      () => this.setState(ProjectsStore.getState()),\n      undefined\n    );\n\n    render() {\n      return (\n        <WrappedComponent\n          {...(this.props as P)}\n          projects={this.state.projects}\n          loadingProjects={this.state.loading}\n        />\n      );\n    }\n  }\n\n  return WithProjects;\n}\n\nexport default withProjects;\n","var baseFlatten = require('./_baseFlatten'),\n    toInteger = require('./toInteger');\n\n/**\n * Recursively flatten `array` up to `depth` times.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @param {number} [depth=1] The maximum recursion depth.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * var array = [1, [2, [3, [4]], 5]];\n *\n * _.flattenDepth(array, 1);\n * // => [1, 2, [3, [4]], 5]\n *\n * _.flattenDepth(array, 2);\n * // => [1, 2, 3, [4], 5]\n */\nfunction flattenDepth(array, depth) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : toInteger(depth);\n  return baseFlatten(array, depth);\n}\n\nmodule.exports = flattenDepth;\n"],"sourceRoot":""}